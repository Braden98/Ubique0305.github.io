<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Ubik的技术分享与学习记录"/><meta name="keywords" content="技术 Java Rust" /><link rel="alternate" href="/atom.xml" title="Ubik's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yoursite.com/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7f52ad98103933a0875502b3b2a71682";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>Ubik's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ubik's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ubik's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/08/01/2019-08-02-Rust%20%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">Rust 的错误处理</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-01
        </span></div>
    </header>

    <div class="post-content"><p>在 Rust 中，错误处理主要包括显式的 panic 和 Option。</p>
<p>一个使用 panic 的例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">give_princess</span></span>(gift: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 公主讨厌蛇，所以如果公主表示厌恶的话我们要停止！</span></span><br><span class="line">    <span class="keyword">if</span> gift == <span class="string">"snake"</span> &#123; <span class="built_in">panic!</span>(<span class="string">"AAAaaaaa!!!!"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I love &#123;&#125;s!!!!!"</span>, gift);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当错误有可能发生，且应当由调用者处理时，使用 Result 而不是 unwrap 然后 使用 expect，除非是在测试或者 prototype develop.</li>
</ul>
<p>std 中的 Option<T> enum 类型用于可能有“不存在”的情况，其内容包括</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Some(T)//找到一个属于 T 类型的元素</span><br><span class="line">None//相当于null</span><br></pre></td></tr></table></figure>
<p>之后用 <code>match</code> 进行显式的处理或者 <code>unwarp</code> 隐式处理。后者要么返回 some 内部元素，要么直接 panic。</p>
<p>一个用 match 处理的例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">give</span></span>(gift: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt;)&#123;</span><br><span class="line">    <span class="keyword">match</span> gift&#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="string">"snake"</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"fuck"</span> ),</span><br><span class="line">        <span class="literal">Some</span>(inner) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,inner ),</span><br><span class="line">        <span class="literal">None</span> =&gt;<span class="built_in">println!</span>(<span class="string">"???"</span> ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意这里要用 Some 包装，直接传字符串会报错</span></span><br><span class="line"><span class="comment">//————你看 give 的 para 就知道了</span></span><br><span class="line"><span class="keyword">let</span> food = <span class="literal">Some</span>(<span class="string">"food"</span>);</span><br><span class="line"><span class="keyword">let</span> snake = <span class="literal">Some</span>(<span class="string">"snake"</span>);</span><br><span class="line"><span class="keyword">let</span> void = <span class="literal">None</span>;</span><br><span class="line">give(food);</span><br><span class="line">give(<span class="literal">None</span>);</span><br><span class="line">give(snake);</span><br><span class="line">give(void);</span><br></pre></td></tr></table></figure>

<p>从上边可以看出来，当 match 很多事，使用较为繁琐，此时可以使用组合算子（combinator），以 模块化的风格来管理控制流。主要就是用 closure 方便地对主要情况而非特殊情况（None）进行处理，例子如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(food: <span class="built_in">Option</span>&lt;Food&gt;) -&gt; <span class="built_in">Option</span>&lt;Cooked&gt; &#123;</span><br><span class="line">    food.map(|f| Peeled(f))</span><br><span class="line">        .map(|Peeled(f)| Chopped(f))</span><br><span class="line">        .map(|Chopped(f)| Cooked(f))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map() 以链式调用的方式来简化 match 语句。然而，如果以返回类型是 Option<T> 的函数作为 map() 的参数，会导致出现嵌套形式 Option&lt;Option<T>&gt;。这样多层串联 调用就会变得混乱。所以有必要引入 and_then()，在某些语言中它叫做 flatmap。例子如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要做一份好菜，我们需要原材料和食谱。</span></span><br><span class="line"><span class="comment">// 我们可以借助一系列 `match` 来表达这个逻辑：</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">cookable_v1</span></span>(food: Food) -&gt; <span class="built_in">Option</span>&lt;Food&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> have_ingredients(food) &#123;</span><br><span class="line">        <span class="literal">None</span>       =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(food) =&gt; <span class="keyword">match</span> have_recipe(food) &#123;</span><br><span class="line">            <span class="literal">None</span>       =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="literal">Some</span>(food) =&gt; <span class="literal">Some</span>(food),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 `and_then()` 把上面的逻辑改写得更紧凑：</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">cookable_v2</span></span>(food: Food) -&gt; <span class="built_in">Option</span>&lt;Food&gt; &#123;</span><br><span class="line">    have_ingredients(food).and_then(have_recipe)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Result 是 Option 类型的更丰富的版本，描述的是可能 的错误而不是可能的不存在。<br>Result 有很多类似 Option 的方法。例如 unwrap()，它要么举出元素 T，要么就 panic.我们希望把 错误返回给调用者，这样它可以决定回应错误的正确方式。<br>例子如下</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 我们试着用 `unwrap()` 把数字放出来。它会咬我们一口吗？</span></span><br><span class="line">    <span class="keyword">let</span> first_number = first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap();</span><br><span class="line">    <span class="keyword">let</span> second_number = second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap();</span><br><span class="line">    first_number * second_number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从unwrap改为模式匹配</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(first_number)  =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;() &#123;</span><br><span class="line">                <span class="literal">Ok</span>(second_number)  =&gt; &#123;</span><br><span class="line">                    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组合算子</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;().and_then(|first_number| &#123;</span><br><span class="line">        second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;().map(|second_number| first_number * second_number)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 match 和 提前返回 early return 代替组合算子</span></span><br><span class="line"><span class="comment">// 注意 return ，终于用到了哈哈哈</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> first_number = <span class="keyword">match</span> first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(first_number)  =&gt; first_number,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> second_number = <span class="keyword">match</span> second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(second_number)  =&gt; second_number,</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// unwrap 且避免产生 panic，? 几乎1 就等于一个会返回 Err 而不是 panic 的 unwrap</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> first_number = first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="keyword">let</span> second_number = second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在出现 ？以前，是使用 try! 宏的，栗子如下</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> first_number = <span class="built_in">try!</span>(first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;());</span><br><span class="line">    <span class="keyword">let</span> second_number = <span class="built_in">try!</span>(second_number_str.parse::&lt;<span class="built_in">i32</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">Ps:为了减少代码量，可以使用 </span><br><span class="line">```rust</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AliasedResult</span></span>&lt;T&gt; = <span class="built_in">Result</span>&lt;T, ParseIntError&gt;;</span><br></pre></td></tr></table></figure>
<p>这样，函数名可以改为</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiply</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_number_str: &amp;<span class="built_in">str</span>) -&gt; AliasedResult&lt;<span class="built_in">i32</span>&gt;</span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<ol>
<li><a href="https://doc.rust-lang.org/rust-by-example/" target="_blank" rel="noopener">Rust by Example</a></li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/07/13/2019-08-22-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">分布式事务的原理与实现</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-13
        </span></div>
    </header>

    <div class="post-content"><p>看《从 Paxos 到 Zookeeper》看的很爽，于是在 唯一了解的 CAP 和选举问题之外，系统地整理了分布式事务的相关问题。</p>
<h1 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h1><p>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<p>换句话说，分布式事务 = n 个本地事务。通过事务管理器，达到 n 个本地事务要么全部成功，要么全部失败。</p>
<h1 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h1><p>一句话：单机装不下了(……)至于是数据量太大还是为了性能或者计算能力，下边慢慢说。<br>举世闻名（……）的微服务就是把一个项目整体拆分成由不同事务组成的模块，显然不同的模块分布在不同的逻辑块上。<br>举个例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护。<br>这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。<br>另一个原因是数据库要做分库分表。当然从实际角度考虑，在千万量级之前，做数据库的分库分表并不是什么好主意。<br>但即使不这样，NoSQL 自带的分布式特性使得常用来做缓存的 Redis 也需要使用者了解一定的分布式知识（这句话很绕，但词法和语法分析都没问题，哈哈）</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>数据库的 ACID 满足了数据库本地事务的基础，但是它无法满足分布式事务，这个时候衍生了 CAP 和 BASE 两个经典理论。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>CAP 理论</p>
<p>CAP 定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP 就是你的入门理论。</p>
<ul>
<li><p>C (一致性)：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p>
</li>
<li><p>A (可用性)：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p>
</li>
<li><p>P (分区容错性)：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</p>
</li>
</ul>
<p>高可用、数据一致性是很多系统设计的目标，但是分区又是不可避免的事情。我们来看一看分别拥有 CA、CP 和 AP 的情况。</p>
<ul>
<li>CA without P：如果不要求 P（不允许分区），则 C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此 CA 的系统更多的是允许分区后各子系统依然保持 CA 。<ul>
<li>单机的Oracle或MySQL之类的传统RDBMS数据库没有分区容错，是CA系统，可以达到强一致性和可用性。</li>
</ul>
</li>
</ul>
<ul>
<li><p>CP without A：如果不要求 A（可用），相当于每个请求都需要在 Server 之间强一致，而 P（分区）会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p>
<ul>
<li><p>半同步复制在master写binlog成功之后不立即提交，而是等待其中一个slave同步成功，只要有一个slave同步成功，立即提交。这种方式比异步复制性能稍差（需要等待至少一个slave同步成功才提交），但是在一定程度上保证了数据一致性（依然不是CP系统：如果同步slave2失败，master和slave1在commit之后挂了，slave2对外提供服务，从slave2中无法查询到刚才提交的数据）。</p>
<p><img src="/img/8904178FA8EA0F47AFE1CB749F7E4AD5.jpg" alt="插图"></p>
</li>
</ul>
</li>
<li><p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p>
<ul>
<li><p>Mysql 的异步复制在master写binlog成功之后立即提交，不等待slave的同步结果。这种方式有很高的性能，但是牺牲了数据一致性。如果slave同步不成功就会造成master和slave数据不一致。异步复制虽然性能高（A），但是数据有可能不一致（C），所以异步复制是AP系统。</p>
<p><img src="/img/5728A35581B66B735DDC81C3670D02AD.jpg" alt="插图"></p>
</li>
</ul>
</li>
</ul>
<h3 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下"></a>总结如下</h3><ul>
<li>MySQL 主从异步复制是 AP 系统。</li>
<li>MySQL 主从半同步复制是 CP 系统。</li>
<li>Zookeeper 是 CP 系统。</li>
<li>Redis 主从同步是 AP 系统。</li>
<li>Eureka 主从同步是 AP 系统。</li>
</ul>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性) 三个短语的缩写。是对 CAP 中AP 的一个扩展</p>
<p>BA 基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。<br>S 软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。<br>E 最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。<br>BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。</p>
<p>BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p>
<p>对于大部分的分布式应用而言，只要数据在规定的时间内达到最终一致性即可。我们可以把符合传统的 ACID 叫做刚性事务，把满足 BASE 理论的最终一致性事务叫做柔性事务。<br>具体到分布式事务的实现上，业界主要采用了 XA 协议的强一致规范以及柔性事务的最终一致规范。</p>
<h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><ol>
<li><p>XA 方案</p>
</li>
<li><p>TCC 方案</p>
</li>
<li><p>本地消息表</p>
</li>
<li><p>可靠消息最终一致性方案</p>
</li>
<li><p>最大努力通知方案</p>
</li>
<li><p>SAGA</p>
</li>
</ol>
<h2 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h2><p>XA 是 X/Open CAE Specification (Distributed Transaction Processing)模型，它定义的 TM（Transaction Manager）与 RM（Resource Manager）之间进行通信的接口。</p>
<p>Java中 的 javax.transaction.xa.XAResource 定义了 XA 接口，它依赖数据库厂商对 jdbc-driver 的具体实现。</p>
<p>mysql-connector-java-5.1.30 的实现可参 com.mysql.jdbc.jdbc2.optional.MysqlXAConnection 类。<br>在 XA 规范中，数据库充当 RM 角色，应用需要充当 TM 的角色，即生成全局的 txId ，调用 XAResource 接口，把多个本地事务协调为全局统一的分布式事务。</p>
<p>目前 XA 有两种实现：</p>
<ol>
<li><p>基于一阶段提交( 1PC ) 的弱 XA 。</p>
</li>
<li><p>基于二阶段提交( 2PC ) 的强 XA 。</p>
</li>
</ol>
<h3 id="弱XA"><a href="#弱XA" class="headerlink" title="弱XA"></a>弱XA</h3><p>弱 XA 通过去掉 XA 的 Prepare 阶段，以达到减少资源锁定范围而提升并发性能的效果。典型的实现为在一个业务线程中，遍历所有的数据库连接，依次做 commit 或者 rollback。同本地事务相比，性能损耗低，但在事务提交的执行过程中，若出现网络故障、数据库宕机等预期之外的异常，将会造成数据不一致，且无法进行回滚。<br>目前 MyCAT、Sharding-Sphere 默认支持。</p>
<h3 id="强XA"><a href="#强XA" class="headerlink" title="强XA"></a>强XA</h3><p>二阶段提交是 XA 的标准实现。它将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback 。<br>    - 第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。<br>    - 第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。<br>开启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：<br>    - 当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。<br>    - 若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。<br>    -如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA recover 再次进行 commit 补偿，以保证数据的一致性。</p>
<p>尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。但会有很多问题</p>
<ol>
<li>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>
<li>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源</li>
<li>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。<br>可以采用现成的 Sharding Sphere来解决， 支持基于 XA 的强一致性事务解决方案，可以通过 SPI 注入不同的第三方组件作为事务管理器实现 XA 协议，如 Atomikos 和 Narayana 。<br>这个方案很少用————数据库一般不能跨服务操作————自己的服务有自己的数据库。一个反例是马云爸爸的88会员，真的🐂🍺。</li>
</ol>
<h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>TCC 模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm / Cancel 接口，其本质也是 2PC ，只是 TCC 在应用层控制。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>Try:<ul>
<li>尝试执行业务</li>
<li>完成所有业务检查（一致性）</li>
<li>预留必须业务资源（准隔离性）</li>
</ul>
</li>
<li>Confirm:<ul>
<li>确认执行业务；</li>
<li>真正执行业务，不作任何业务检查</li>
<li>只使用Try阶段预留的业务资源</li>
<li>Confirm 操作满足幂等性</li>
</ul>
</li>
<li>Cancel:<ul>
<li>取消执行业务</li>
<li>释放Try阶段预留的业务资源</li>
<li>Cancel操作满足幂等性<br>这三个阶段，都会按本地事务的方式执行。不同于 XA的prepare ，TCC 无需将 XA 的投票期间的所有资源挂起，因此极大的提高了吞吐量。</li>
</ul>
</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>A –&gt; B 汇款100元。那么汇款服务和收款服务分别需要实现，Try-Confirm-Cancel 接口，并在业务初始化阶段将其注入到 TCC 事务管理器中。<br>汇款服务</p>
<ol>
<li>Try：<ul>
<li>检查A账户有效性，即查看A账户的状态是否为“转帐中”或者“冻结”</li>
<li>检查A账户余额是否充足</li>
<li>从A账户中扣减 100 元，并将状态置为“转账中”</li>
<li>预留扣减资源，将从 A 往 B 账户转账 100 元这个事件存入消息或者日志中</li>
</ul>
</li>
<li>Confirm：<ul>
<li>不做任何操作</li>
</ul>
</li>
<li>Cancel：<ul>
<li>A 账户增加 100 元</li>
<li>从日志或者消息中，释放扣减资源<br>收钱服务</li>
</ul>
</li>
<li>Try：<ul>
<li>检查 B 账户账户是否有效；</li>
</ul>
</li>
<li>Confirm：<ul>
<li>读取日志或者消息，B 账户增加 100 元</li>
<li>从日志或者消息中，释放扣减资源；</li>
</ul>
</li>
<li>Cancel：<ul>
<li>不做任何操作<br>由此可以看出，TCC 模型对业务的侵入强，改造的难度大。尽量不用，因为代码，尤其是回滚很麻烦。<br>但是，在需要前置资源锁定的场景，不得不使用 XA 或 TCC 的方式。再例如说，下单场景，在订单创建之前，需要扣除如下几个资源：</li>
</ul>
</li>
</ol>
<ul>
<li>优惠劵</li>
<li>钱包余额</li>
<li>积分</li>
</ul>
<p>那么，不得不进行前置多资源锁定，无非是使用 XA 的强锁，还是 TCC 的弱锁。在 oceans 的 tag 0.0.1 中，在未使用 TCC 的情况下，模拟 TCC 的效果的苦闷。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p><img src="/img/02EDF3EDC128207E5786CC98F8722538.jpg" alt="插图"></p>
<ol>
<li><p>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</p>
</li>
<li><p>接着 A 系统将这个消息发送到 MQ 中去；</p>
</li>
<li><p>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</p>
</li>
<li><p>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</p>
</li>
<li><p>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</p>
</li>
<li><p>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</p>
</li>
</ol>
<h2 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h2><p>不要用本地的消息表了，直接基于 MQ 来实现事务，具体如下<br><img src="/img/3507F4657A6C7DA9A2346EB210888D9E.jpg" alt="插图"></p>
<ol>
<li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li>
<li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li>
<li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li>
<li>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li>
<li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCC 和 MQ 都是以服务为范围进行分布式事务的处理，而 XA、BED、SAGA 则是以数据库为范围进行分布式处理。<br>对于数据库中间件来说，更趋向于选择后者，对于业务而言侵入小，改造的成本低。<br>Ps: 两个 2PC 事务的开源框架，<a href="https://github.com/Dromara/Raincat" target="_blank" rel="noopener">Raincat</a>&amp;<a href="https://github.com/codingapi/tx-lcn" target="_blank" rel="noopener">LCN</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://my.oschina.net/lhztt/blog/915533" target="_blank" rel="noopener">分布式系统理论（一）：CAP定理</a></li>
<li><a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">Base: An Acid Alternative</a></li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/06/15/2019-05-30-RCU/">了解并发编程中的RCU</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-15
        </span></div>
    </header>

    <div class="post-content"><p>为了保护共享数据,需要一些同步机制,如自旋锁(spinlock)，读写锁(rwlock),CPU的速度与访问内存的速度差距越来越大，而这种锁使用了原子操作指令，它需要原子地访问内存，也就说获得锁的开销与访存速度相关，另外在大部分非x86架构上获取锁使用了内存栅(Memory Barrier)，这会导致处理器流水线停滞或刷新，因此它的开销相对于CPU速度而言就越来越大。<br><a href="https://www.ibm.com/developerworks/cn/linux/l-rcu/index.html" target="_blank" rel="noopener">RCU</a><br>RCU(Read-Copy Update),读，拷贝更新,是一种基于延后处理的同步机制，在 2002 年 10 月 引入 Linux 内核。它允许读操作与更新操作并发执行而不是像常规的互斥锁一样让线程串行执行，从而提高了程序的可扩展性，相较于读写锁，有更好的性能。在非抢占式的内核里，RCU 读端的函数完全是 0 开销。</p>
<p>RCU 由三种机制构成</p>
<ol>
<li><p>用于插入的订阅机制</p>
</li>
<li><p>等待已有 RCU 结束的方法</p>
</li>
<li><p>使读端不受并发插入、删除的干扰的机制，也即维护多个版本的准则。</p>
</li>
</ol>
<p><a href="https://cloud.tencent.com/developer/article/1006226" target="_blank" rel="noopener">MESI是一种内存缓存一致性协议</a>， 存在“modified”，“exclusive”，“shared”和“invalid”四种状态，协议可以在一个指定的缓存行中应用这四种状态。因此，协议在每一个缓存行中维护一个两位的状态标记，这个标记附着在缓存行的物理地址和数据后面。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/06/13/2019-05-28-%E7%94%A8%20Optional%20%E5%8F%96%E4%BB%A3%20null/">用 Optional 取代 null 的思考</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-13
        </span></div>
    </header>

    <div class="post-content"><h1 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h1><p>空指针异常 <code>NullPointerExpection</code> 是在 Java 开发过程中常见的异常，当我们访问数组中超过其长度-1的 Index 时，或者对 null 进行<code>.</code>运算时都会引发这个异常。一般来说，可以通过防御式检查<code>if(Object != null</code>来减少之。但很明显，这种方式牺牲了可读性，而且因为逐层潜嵌套，降低了可扩展性。而为了避免逐层嵌套使用多个返回值，那么可维护性就降低了。<br>实际上，空指针及对它的预防都有很多问题。</p>
<ul>
<li><p>它代表的是在静态类型语言中以一种错误的方式对缺失变量值的建模，本身没有任何意义。</p>
</li>
<li><p>它会使代码膨胀</p>
</li>
<li><p>Java一直试图避免让程序员意识到指针的存在，唯一的例外是：null指针</p>
</li>
<li><p>null并不属于任何类型， 这意味着它可以被赋值给任意引用类型的变量。这会导致问题，原因是当这个变量被传递到系统中的另一个部分后，你将无法获知这个null变量最初的赋值到底是什么类型。</p>
</li>
</ul>
<p>在 Java8 中提供了 Option 类来解决这个问题。————当你知道类中某个属性可能为 null 时，采用  <code>Optional&lt;class&gt;</code> 来代替 <code>class</code>.这样，从静态代码的角度，我们至少可以知道哪些值可为 null，哪些不可，方便我们排查错误。</p>
<p>官方文档描述如下</p>
<blockquote>
<p>A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.</p>
</blockquote>
<p>那么，Optional 和 null 到底有什么区别呢？实际上，变量存在时， Optional类只是对类简单封装。变量不存在时， 缺失的值会被建模成一个“空”的Optional对象，由方法 <code>Optional.empty()</code> 返回。<code>Optional.empty()</code> 方法是一个静态工厂方法，它返回 Optional 类的特定单一实例。你可能还有疑问，null 引用和 <code>Optional.empty()</code> 有什么本?的区别吗？从语义上， 你可以把它们当作一回事儿， 但是实际中它们之间的差别非常大 ： 如果你尝试解引用一个 null ， 一 定 会 触发 NullPointerException ，不过使用 <code>Optional.empty()</code> 就完全没事，它是 Optional 类的一个有效对象，多种场景都能调用，非常有用。</p>
<h2 id="创建-Optional-对象"><a href="#创建-Optional-对象" class="headerlink" title="创建 Optional 对象"></a>创建 Optional 对象</h2><ol>
<li><p>声明一个空的 Optional<br><code>Optional&lt;Car&gt; optCar = Optional.empty();</code></p>
</li>
<li><p>依据一个非空值创建 Optional<br><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></p>
</li>
<li><p>创建可接受null的Optional</p>
<p> <code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code></p>
</li>
</ol>
<h2 id="使用-map-从-Optional-对象中提取和转换值"><a href="#使用-map-从-Optional-对象中提取和转换值" class="headerlink" title="使用 map 从 Optional 对象中提取和转换值"></a>使用 map 从 Optional 对象中提取和转换值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; name =</span><br><span class="line">optInsurance.map(Insurance::getName;</span><br></pre></td></tr></table></figure>
<h2 id="使用-flatMap-链接-Optional-对象"><a href="#使用-flatMap-链接-Optional-对象" class="headerlink" title="使用 flatMap 链接 Optional 对象"></a>使用 flatMap 链接 Optional 对象</h2><p>链式调用 map() 根本无法通过编译，原因是 Optional 发生了嵌套，可以使用 flatMap 完成.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.flatMap(Person::getCar)  </span><br><span class="line">.flatMap(Car::getInsurance)  </span><br><span class="line">.map(Insurance::getName) </span><br><span class="line">.orElse(<span class="string">"Unknown"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="无法序列化的-Optional"><a href="#无法序列化的-Optional" class="headerlink" title="无法序列化的 Optional"></a>无法序列化的 Optional</h2><p>Java??的架构师 Brian Goetz曾 经非常明确地说过，Optional的设计初衷仅仅是要支持能返回Optional对象的语法，所以它也并未实现Serializable接口，如果你一定要实现序列化的模型，可以这样做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Car car;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCarAsOptional</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(car);  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/06/13/2019-07-04-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E5%8F%8AGET%20Bucket%20(List%20Objects)%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/">对象存储的优势及实习问题记录</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-13
        </span></div>
    </header>

    <div class="post-content"><h1 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h1><p>“对象存储”来源于英文“Object Storage”或“Object-based Storage”</p>
<h3 id="特性与目标"><a href="#特性与目标" class="headerlink" title="特性与目标"></a>特性与目标</h3><p>多租户<br>不假设数据特征，包括类型，大小等<br>存储空间可无限扩展，且性能该随容量水平扩展而线性提升，不然数据量越大，请求越多，性能却不提升，系统的存取性能只会越来越慢<br>数据安全<br>服务高可靠</p>
<h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><p>顶级命名空间service+bucket即可</p>
<h3 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h3><p>属于哪个存储空间<br>类型<br>大小<br>校验值<br>最后修改时间</p>
<h4 id="特殊元信息"><a href="#特殊元信息" class="headerlink" title="特殊元信息"></a>特殊元信息</h4><p>演唱者是谁<br>作词者是谁<br>作曲者是谁<br>属于哪张唱片<br>属于什么风格</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>传统存储中，块存储暴露Block 文件系统或者网络文件系统如NFS暴露POSIX接口</p>
<h2 id="DAS-Direct-Attached-Storage"><a href="#DAS-Direct-Attached-Storage" class="headerlink" title="DAS  Direct-Attached Storage"></a>DAS  Direct-Attached Storage</h2><p>直连式存储。直接连接到某台计算机且其他计算机无法获取，如PC的硬盘驱动器。因为服务器无需通过网络来读写数据，所以DAS能为终端用户提供比网络存储更高的性能。如微软公司推荐使用DAS安装Exchange。<br>缺点是依赖服务器主机操作系统进行数据的IO读写和存储维护管理，数据备份和恢复要求占用服务器主机资源（包括CPU、系统IO等）。直连式存储的数据量越大，备份和恢复的时间就越长，对服务器硬件的依赖性和影响就越大。 </p>
<h2 id="NAS-Network-Attached-Storage"><a href="#NAS-Network-Attached-Storage" class="headerlink" title="NAS  Network-Attached Storage"></a>NAS  Network-Attached Storage</h2><p>网络附属存储/网络接入存储<br>简单说就是连接在网络上，具备资料存储功能的装置，也因此称为网络存储器。将存储设备与服务器彻底分离，底层磁盘通过文件系统类型（分区，格式化后）通过网络的方式（发送ip包）共享给前端应用</p>
<h2 id="SAN-Storage-Area-Network"><a href="#SAN-Storage-Area-Network" class="headerlink" title="SAN Storage Area Network"></a>SAN Storage Area Network</h2><p>存储区域网络<br> 通过光纤设备将存储设别和服务器连接一起，数据和服务器分离，底层磁盘以块的模式共享给前端的应用服务器。<br> SAN是一个采用网状通道（简称FC）技术，通过FC交换机连接存储阵列和服务器主机，建立专用于数据存储的区域网络。<br> <img src="/img/5E33AC1A918F56A6FFCF48F433A594BF.jpg" alt="插图"></p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul>
<li><p>服务可用性更高<br>通过支持对象数据的高可靠性和业务节点的高可靠性网络、节点的多冗余设计，系统设计可用性达到99.99%。</p>
</li>
<li><p>数据可靠性更高<br>通过提供对象数据多份冗余和保证多份对象的数据一致性自动修复技术来提供对象数据的高可靠性。OBS系统设计的数据持久性高达99.999999999%（11个9），意为对象存储服务里1000亿个用户文件，每月最多只有1个文件发生数据丢失的可能性。</p>
</li>
<li><p>用户数据更安全<br>用户数据传输到OBS时支持SSL加密，同时，OBS通过AK/SK对访问用户的身份进行鉴权，且结合了ACL、桶策略等多种方式对桶和对象进行访问控制，确保数据传输与访问的安全。此外，用户所上传的对象数据在对象存储服务中分片随机存储在不同硬盘上，所以即便磁盘数据被盗走，也无法将其还原成对象数据。</p>
</li>
<li><p>容量无限扩展<br>OBS所有业务、存储节点采用分布式集群方式工作，各功能节点、集群都可以独立扩容，整个扩容过程对用户完全透明。用户只需尽情享用云存储带来的无限空间，不必预测未来的存储需求并可以按需要向上和向下扩展，从而大幅提高业务灵活性。</p>
</li>
<li><p>维护成本更低<br>由于数据存储在OBS中，企业无需招聘专门的存储设备维护人员，设备的维护交由OBS处理即可。</p>
</li>
</ul>
<h1 id="实习问题记录"><a href="#实习问题记录" class="headerlink" title="实习问题记录"></a>实习问题记录</h1><h2 id="为什么GET-Bucket-List-Objects-在Object多时会慢？"><a href="#为什么GET-Bucket-List-Objects-在Object多时会慢？" class="headerlink" title="为什么GET Bucket (List Objects)在Object多时会慢？"></a>为什么GET Bucket (List Objects)在Object多时会慢？</h2><p>原问题“get bucket那个接口的实现比较麻烦，在object的量很大的情况下，这个接口的性能会很差。你可以想想这个问题”<br>根据API文档所说</p>
<ol>
<li>数据量大，多次循环调用该 API才可获得给定 Prefix 条件的所有对象列表。不像其他API只需要一次Http通信；网络通信次数多，</li>
<li>需要模拟文件系统的目录结构，对delimiter划分的相同前缀的多个对象遍历和合并。底层实现需要较深的函数调用栈或者内存空间。</li>
<li>Object数量多时更改更频繁，缓存容易失效</li>
</ol>
<p>不知道元信息的存储系统是否支持事务，如果不支持，并发情况下我觉得会加共享锁（读锁），锁竞争也会带来性能开销。可以用redis、zookeeper做分布式协调组件的情况下，可以多个请求竞争一个锁，只有一个请求到达并被处理，然后更新缓存供其他请求使用，从而提高吞吐量</p>
<p>就是关于 GET Bucket (List Objects)在Object多时性能很差的问题，有没有这几个原因</p>
<ol>
<li>网络IO次数多。根据文档所说，利用marker参数多次迭代调用该 API才可获得给定 Prefix 条件的所有对象列表。</li>
<li>计算资源消耗大。文档说支持用delimiter模拟文件系统的目录结构，对delimiter划分的相同前缀的多个对象遍历和合并。这需要较深的函数调用栈或者内存空间以及计算量。</li>
<li>保持实时性和一致性带来的开销。如文档所说，缓存容易失效，这会导致更多磁盘IO和数据处理。且读取过程中要加共享锁防止元数据被修改导致的一致性问题。</li>
</ol>
<p>看文档我觉得服务器应该是一次完成所有数据的处理，但要分段返回是因为数据可能太大吗？</p>
<p>关于处理方法<br>文档说因为性能问题不要依赖这个接口的并发调用，而是用户自己缓存数据，这是不是说对数据的准确性要求不太高。那这样后端在并发情况下通过选举其中一个请求到达服务器，从mysql或别的拿到结果放入缓存，其他请求都走缓存，就可以一定程度解决吞吐量的问题。同样，通过elasticsearch或者其他放弃事务机制的搜索方式元数据提高响应速度</p>
<h2 id="Q：“假设现在数据量在单机承受能力之内，用mysql来存储元信息，怎么处理list请求”"><a href="#Q：“假设现在数据量在单机承受能力之内，用mysql来存储元信息，怎么处理list请求”" class="headerlink" title="Q：“假设现在数据量在单机承受能力之内，用mysql来存储元信息，怎么处理list请求”"></a>Q：“假设现在数据量在单机承受能力之内，用mysql来存储元信息，怎么处理list请求”</h2><p>比如按照Zone划分表，表中有所属bucket信息，类型，大小，校验值，最后修改时间，特殊元信息等字段，可以在编程语言层面记录已经处理过的bucket，实现下次根据marker参数继续处理。事务机制（隔离性）可以方便地保证一致性问题，同时可以对marker或其他字段走索引加快IO速度。<br>mysql8之后已不自带缓存，如文档所说如果要加缓存可以用redis。同时在编程语言层面利用元信息的最后修改时间字段实现缓存自动更新。</p>

        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:Dingbiao1998@icloud.com" target="_blank" rel="noopener" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Ubique0305" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="copyright-year">&copy;2018 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Adam Ubik</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
<script src="/node_modules/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"node_modules/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/node_modules/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
