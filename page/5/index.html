<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Ubik的技术分享与学习记录"/><meta name="keywords" content="技术 Java Rust" /><link rel="alternate" href="/default" title="Ubik's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yoursite.com/page/5/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>Ubik's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ubik's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ubik's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/01/2019-05-31-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/">最长回文子串的优化过程</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-content"><p>这里分享一道有趣的题目，笔者在 POJ 上使用多种不同的方法进行求解，这其中包括最基本的暴力解、动态规划、分治算法+字符串哈希以及 Manacher 算法和后缀数组。其算法的手写难度不断增加，但时间空间复杂度不断下降。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>聪明的计算机科学的学生安迪正在参加一个算法课，教授问学生一个简单的问题：“你能提出一个有效的算法来找出字符串中最大回文长度吗？”<br>如果一个字符串向前和向后读相同，例如“madam”是回文，而“ACM”则不是回文，则称为回文。<br>学生们认识到这是一个经典的问题，但无法给出一个比遍历所有子串和检查它们是否是回文的方法更好的解答，过了一会儿安迪举起手说：“好吧，我有一个更好的。”在他开始解释他的想法之前，他停了一会儿，然后说：“嗯，我有一个更好的算法！”.<br>如果你认为你知道安迪的最终解决方案，那就证明它吧！给定一个最多1000000个字符的字符串，查找并打印字符串中最大回文长度。</p>
</blockquote>
<h2 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h2><p>枚举字符串的每一个子串，判断其是否是回文串，如果是且比 <code>res.length()</code>，就更新 res 。枚举每个字串需要 O(n^2) 的时间复杂度，判断每一个子串是否为回文串需要 O(n) 的时间复杂度，因此，总的时间复杂度为 O(n^3). 思路非常简单，这里不再赘述,实现如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String res=s.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= s.length(); j++) &#123;</span><br><span class="line">                String k=s.substring(i,j);</span><br><span class="line">                String rk=<span class="keyword">new</span> StringBuffer(k).reverse().toString();</span><br><span class="line">                <span class="keyword">if</span>(k.equals(rk)&amp;&amp;k.length()&gt;res.length())&#123;</span><br><span class="line">                    res=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>因为之前解决过最长公共子串 LCS 的问题，于是很自然地想到，将题目所给字符串倒置，利用回文串正序读和逆序读结果一样的特性，对其求 LCS ，res 就是本题的答案。但在制作 case 的时候，笔者发现这是错误的解法，因为一旦原来的字符串中已经同时存在某个字串及其逆序，这个算法就无法找到最长的那一个。比如abcdefcba，输出的是错误结果 abc。</p>
<p>所以应该换如下思路：令 <code>dp[i][j]</code> 表示 <code>S[i]~S[j]</code> 所表示的子串是否是回文子串，是则为1，不是则为0，这样根据 <code>S[i]是否=S[j]</code> ，可以把转移情况分成两类</p>
<ol>
<li><code>S[i]==S[j]</code> ,那么只要 <code>S[i+1]～S[j-1]</code> 是回文子串，那么 <code>S[i]~S[j]</code> 就是回文子串，如果 <code>S[i+1]～S[j-1]</code> 不是回文子串，那么 <code>S[i]~S[j]</code> 就不是回文子串。</li>
<li><code>S[i]!=S[j]</code> ，那么 <code>S[i]~S[j]</code> 就不是回文子串。</li>
</ol>
<p>由此可得状态转移方程 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=S[i]==S[j]? dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>但还有一个问题，对于该状态转移方程，如果按照 i 和 j 从小到大的顺序来枚举子串的两个端点，然后更新 <code>dp[i][j]</code> ，会无法保证 <code>dp[i+1][j-1]</code> 已经被计算过，出现空指针异常。注意到回文子串的对称性，通过手动计算 dp 二维数组，发现可通过枚举子串长度的方式进行第一轮遍历，第二遍按照子串的初始位置进行遍历，如此，即可获得正确的dp数组。<br>时间复杂度方面，先枚举子串的长度再枚举作第一轮循环，再枚举子串的起始端点作为第二轮循环，因此时间复杂度为 O(n^2),比最基本的蛮力法要好多了。关键代码如下所示（笔者大二上提交 OJ 的 C++ 代码）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> L = <span class="number">3</span>; L &lt;= len; L++)<span class="comment">//枚举子串的长度作为一轮遍历的方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + L - <span class="number">1</span> &lt; len; i++)<span class="comment">//枚举子串的起始端点作为第二轮循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + L - <span class="number">1</span>;<span class="comment">//子串的右端点</span></span><br><span class="line">        <span class="keyword">if</span> (S[i] == S[j] &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            ans = L;<span class="comment">//更新最长回文子串长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于该二重循环，显然其时间复杂度为 O(n^2)。</p>
<h2 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h2><p>从上述动态规划算法中注意到回文子串的中心对称性，可以从字符串的中心开始，向两边分别扩散来检查回文，且对每一个字符都如此操作。每个中心的检查需要线性时间复杂度，遍历整个字符串也是如此，因此总的复杂度为O(n^2)。注意需要分 aba 和 abba 两种情况讨论</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">​    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">​            <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) &#123; </span><br><span class="line">​               <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> begin = centerExpand(s, i, i);                     </span><br><span class="line">            <span class="keyword">int</span>  end = centerExpand(s, i, i + <span class="number">1</span>);    </span><br><span class="line">            <span class="keyword">if</span> (maxLength &lt; Math.max(begin, end))&#123;</span><br><span class="line">                center = i;                                                 </span><br><span class="line">                maxLength = Math.max(begin, end);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(center - (maxLength - <span class="number">1</span>) / <span class="number">2</span>, center + maxLength / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">centerExpand</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = begin, right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串-Hash-amp-二分"><a href="#字符串-Hash-amp-二分" class="headerlink" title="字符串 Hash &amp; 二分"></a>字符串 Hash &amp; 二分</h2><p>在讲之前需要了解字符串进制哈希和查询子串的 hash 值 ，字符串哈希就是一种字符串到数字的映射。进制哈希就是规定进制数 base 和模数 mod 后，将字符串从 a-z 对应 0-26 按 26 进制转换后取模的过程。当然，为了防止哈希冲突（不同字符串有相同哈希值），你可以设置双哈希、大质数来尽可能避免。</p>
<p>例如某字符串前缀的哈希值记为：h[i]，我们哈希时使用的进制为 base，那么有 <code>h[i]=h[i-1]*base+s[i]</code>,记 p[i] 表示 base<br>的 i 次方。从而我们可以以常数时间复杂度得到字符串某子串的哈希值。就像对于数字，1234567，你想获得345，那就用<code>12345-12*345.length*base</code>一样，当然这里的base是10.被减数是12345而不是1234567.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ull <span class="title">get_hash</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后回到回文串的问题，注意到回文子串具有单调性，即回文串的包含中心的子串也是回文串。因此我们可以进行二分，注意和上边的方法一样，需要区分奇回文aba和偶回文abba，最终结果取大即可。奇回文举例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_Search_od</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span><span class="comment">//二分答案中的奇数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val=ask(od[mid]);<span class="comment">//判断长度有没有为am[mid]的回文</span></span><br><span class="line">        <span class="keyword">if</span>(val)<span class="comment">//如果存在且大于maxx，更新maxx</span></span><br><span class="line">        &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">            maxx=max(maxx,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid-<span class="number">1</span>;<span class="comment">//否则减小长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 master theorem 来看，由于哈希的常数时间复杂度，整个的时间复杂度达到了 O(nlogn),比之前的中心扩展、dp 都要好。</p>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>上边几种算法都是当初刷 OJ 自己想出来的，但这个算法太过于巧妙以至于我花了蛮久来理解。该算法由 Glenn Manacher 于1975年发明。是我们先梳理求解过程，然后试图通过对称性理解。<br>该方法基于之前O(n^2)的中心扩展法，Manacher 算法的核心在于之前字符的“扩充”过程可以指导之后字符的“扩充”过程，使得之后每次扩充过程都不是从零开始。具体方法如下</p>
<ol>
<li><p>把每个字符开头、中间和结尾插入填充字符如 # 来组成新的字符串以解决奇回文和偶回文不统一问题。确切的说是处理了偶回文问题，如cc，扩充后为#c#c#,可以从中间轴#处扩充并找到。这个过程是线性时间复杂度的。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line">		<span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line">		<span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">			res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : charArr[index++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对每个字符进行类似之前中心扩展法一样的扩充过程。设置如下三个辅助变量</p>
<pre><code>- 数组 pArr，长度等同于处理后的字符串，pArr[i]的意义是以 i 位置上的字符作为回文中心的情况下，扩出去得到的最大回文半径是多少。比如对于字符串str： #d#b#u#b#d# 来说，pArr为[1,2,1,2,1,6,1,2,1,2,1]

- 整数 pR，指之前遍历的所有字符的所有回文半径中，最右即将到达的位置。还是用 #d#b#u#b#d# 为例：没遍历之前 pR 为 -1，str[0]=&apos;#&apos;，其回文半径为1，所以目前回文半径向右只能扩展到0位置，即将到达的位置为 pR=1。pR只会增大不会减小。
- 整数 index，最近一次 pR 更新时，回文中心的位置。如 str[0] 时 pR更新，index 就为0.</code></pre></li>
<li><p>pArr 中的最大值就是处理后的 str 的最大回文半径，再对应回未加 # 前的字符串，问题就解决了。步骤3就是从左到右计算 pArr 的过程，就是在这个过程中有些情况获得了加速从而最终获得线性时间复杂度。</p>
<pre><code>- 假设现在计算到 str[i]，在i之前的计算过程中，pR和index都是动态更新的。可以分为两种情况。
- 如果pR-1位置没有包住当前的i位置，#d#b#u#b#d# 计算到str[1]=&apos;u&apos;，pR=1，此时和普通做法一样，从i位置向两侧扩展，这样并没有获得加速。
- 如果pR-1位置包住了当前的i位置，如#d#b#u#b#d#计算到 str[6...10]的时候，pR始终为11，此时可以获得优化。根据之前的pR定义我们知道，以 index 为中心，pR-1和pR-1关于index对称的字符是回文串，我们将其称为大回文串。以遍历所在当前位置i为中心的回文串称为右小，i关于index对称的称为左小，有三种情况  
1. 左小和右小完全在左大和右大内部，此时以位置i为中心的最大回文串可以直接确定为从右小&apos;到左小&apos;这一部分。
2. 左小和右小的左侧部分在左大和右大的外部，此时可以直接确定以i为中心的最长回文子串为为右大到右大&apos;这一部分
3. 左小和左大是同一位置，即以i&apos;为中心的最大回文串压在以 index 为中心的最大回文串边界上，此时右小和右大&apos;也肯定同一个位置，此时以i为中心的最大回文串至少是右大&apos;和右大这一段，但可能更大。</code></pre></li>
</ol>
<p>时间复杂度分析，我们可以看出来 Manacher 算法在检查过程中有明显优化，从步骤3来看，在计算一个未知的回文半径时要么完全不需要扩出去检查，要么每扩出去都会让回文半径 pR 到达更右的位置，pR前边已经定义过，只增不减，因此时间复杂度就是O(n)啦。<br>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLcpsLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line">		<span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line">		<span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> pR = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != charArr.length; i++) &#123;</span><br><span class="line">			pArr[i] = pR &gt; i ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (charArr[i + pArr[i]] == charArr[i - pArr[i]])</span><br><span class="line">					pArr[i]++;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">				pR = i + pArr[i];</span><br><span class="line">				index = i;</span><br><span class="line">			&#125;</span><br><span class="line">			max = Math.max(max, pArr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<p> 按照步骤3得到 pArr 之后，再遍历一遍 aArr 数组，找到最大回文半径，然后对应回原来的长度即可（-1）。</p>
<h2 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h2><p>Manacher 算法虽然巧妙，但是需要很大的技巧，理解有些困难，这里有一种更加通用的解法，就是后缀树。<br>设S[i]表示字符串从i位置到最后的子数组，用S[i…S.length()-1]这些子数组构造 <a href="https://ubique0305.github.io/2019/03/22/Trie/" target="_blank" rel="noopener">Trie 树</a>，就得到后缀树。且将重复节点按如下规则<br>        1. 每个节点可以存储多个字母<br>        2. 字符串后+一个符号结尾，以防因某后缀是其他后缀的前缀而被压缩<br>压缩后，就得到压缩后缀树。</p>
<p>那么这和最长回文子串有什么关系呢？实际上有如下关系 <strong>str与其逆序的最长公共前缀是其最长回文子串的半径对应的字符串</strong>，从而，我们将求最长回文子串的问题转化为求某字符串与其逆序的最长公共前缀问题（LCA），利用 trie 求 LCA 方法如下：反转 str，两者生成的所有后缀子串压入到 trie 中，计算<code>S1(i)</code>与<code>S2(n-i+1)</code>节点的最低公共祖先,从而得到其最长公共前缀,再得到最长回文子串。<br>所以问题转化为求两棵树的最低公共祖先，这个问题之前已经解决过了，<a href="https://ubique0305.github.io/2019/03/23/二叉树中两节点的最近公共祖先/" target="_blank" rel="noopener">在这里</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从暴力，到动态规划，到利用其对称性的中心扩展法，再到进位哈希+二分，然后是 Manacher 和后缀树，可以看出，因为回文串特殊的中心对称性，最优解可以做到线性时间复杂度————不可能更低了，你至少需要扫描一遍字符串。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/henry-1202/p/10324966.html" target="_blank" rel="noopener">hash进阶：使用字符串hash乱搞的姿势</a></li>
<li><a href="https://blog.csdn.net/ice110956/article/details/17299453" target="_blank" rel="noopener">后缀树与最长回文子串</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/01/2019-07-05-Scylla&TiDB%20TiKV&glusterFS%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Scylla&TiDB TiKV&CQL 入门</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-content"><p>实习的第一件事就是读本组产品的 API 文档，然后学习系统用到的底层框架。这些东西之前从没看过。</p>
<h1 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>OLTP (Online Transactional Processing) </p>
</li>
<li><p>OLAP (Online Analytical Processing) </p>
</li>
</ul>
<p>通过单机的 RocksDB，我们可以将数据快速地存储在磁盘上；通过 Raft，我们可以将数据复制到多台机器上，以防单机失效。数据的写入是通过 Raft 这一层的接口写入，而不是直接写 RocksDB。通过实现 Raft，我们拥有了一个分布式的 KV，现在再也不用担心某台机器挂掉了。</p>
<p>对于一个 KV 系统，将数据分散在多台机器上有两种比较典型的方案：一种是按照 Key 做 Hash，根据 Hash 值选择对应的存储节点；另一种是分 Range，某一段连续的 Key 都保存在一个存储节点上。TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，我们将每一段叫做一个 Region，并且我们会尽量保持每个 Region 中保存的数据不超过一定的大小(这个大小可以配置，目前默认是 64mb)。每一个 Region 都可以用 StartKey 到 EndKey 这样一个左闭右开区间来描述。</p>
<p>TiKV 集群是 TiDB 数据库的分布式 KV 存储引擎，数据以 Region 为单位进行复制和管理，每个 Region 会有多个 Replica（副本），这些 Replica 会分布在不同的 TiKV 节点上，其中 Leader 负责读/写，Follower 负责同步 Leader 发来的 raft log</p>
<p><img src="/img/3DE33801F12030F0CB76AFE53384C6AA.jpg" alt="插图"></p>
<h1 id="glusterFS"><a href="#glusterFS" class="headerlink" title="glusterFS"></a>glusterFS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GlusterFS (Gluster File System) 是一个开源的分布式文件系统，是 Scale-Out 存储解决方案 Gluster 的核心，具有强大的横向扩展能力，通过扩展能够支持数PB存储容量和处理数千客户端。借助 TCP/IP 或 InfiniBand RDMA 网络将物理分布的存储资源聚集在一起，使用单一全局命名空间来管理数据。</p>
<h1 id="scylla"><a href="#scylla" class="headerlink" title="scylla"></a>scylla</h1><p>开源的分布式NoSQL数据存储。与Apache Cassandra兼容，同时实现更高的吞吐量和更低的延迟。<br><a href="http://www.nosqlnotes.com/technotes/scylla-highlights/" target="_blank" rel="noopener">号称十倍性能于Cassandra的ScyllaDB，究竟祭出了哪些技术”利器”？</a></p>
<h1 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h1><p>Apache Cassandra（社区内一般简称为C*）是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存收件箱等简单格式数据，具有高度可扩展性，可用于管理大量的结构化数据。它提供高可用性，没有单点故障,集 Google BigTable 的数据模型与 Amazon Dynamo 的完全分布式架构于一身。<br>Cassandra 使用了 Google 设计的 BigTable 的数据模型，与面向行 (row)的传统的关系型数据库或键值存储的key-value数据库不同，Cassandra 使用的是宽列存储模型(Wide Column Stores)，每行数据由row key唯一标识之后，可以有最多 20 亿个列，每个列有一个column key标识，每个column key下对应若干value。这种模型可以理解为是一个二维的key-value存储，即整个数据模型被定义成一个类似map&lt;key1, map&lt;key2,value&gt;&gt;的类型。<br><a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">wiki百科</a></p>
<h1 id="Cassandra-Query-Language-CQL-语法"><a href="#Cassandra-Query-Language-CQL-语法" class="headerlink" title="Cassandra Query Language (CQL) 语法"></a>Cassandra Query Language (CQL) 语法</h1><p>与SQL语法类似，但不支持join和子查询<br>结构类似HBase，row x key x value<br>常用命令</p>
<ul>
<li>describe tables</li>
<li>describe keyspaces</li>
<li>source 执行包含命令的文件</li>
</ul>
<p>键空间是一个定义节点上数据复制的命名空间，集群中每个节点对应一个键空间。<br>键、表、行关系通过expand on expand off 可以看的很明白<br>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:tutorialspoint&gt; SELECT * from emp</span><br><span class="line">                  ... ;</span><br><span class="line"></span><br><span class="line">@ Row 1</span><br><span class="line"><span class="comment">-----------+------------</span></span><br><span class="line"> emp_id    | 4</span><br><span class="line"> emp_city  | Pune</span><br><span class="line"> emp_name  | rajeev</span><br><span class="line"> emp_phone | 9848022331</span><br><span class="line"> emp_sal   | 30000</span><br><span class="line"></span><br><span class="line">@ Row 2</span><br><span class="line"><span class="comment">-----------+------------</span></span><br><span class="line"> emp_id    | 3</span><br><span class="line"> emp_city  | null</span><br><span class="line"> emp_name  | null</span><br><span class="line"> emp_phone | null</span><br><span class="line"> emp_sal   | 50000</span><br><span class="line"></span><br><span class="line">(2 rows)</span><br><span class="line">cqlsh:tutorialspoint&gt; SELECT * from emp  ;</span><br><span class="line"></span><br><span class="line"> emp_id | emp_city | emp_name | emp_phone  | emp_sal</span><br><span class="line"><span class="comment">--------+----------+----------+------------+---------</span></span><br><span class="line">      4 |     Pune |   rajeev | 9848022331 |   30000</span><br><span class="line">      3 |     null |     null |       null |   50000</span><br></pre></td></tr></table></figure>
<h2 id="创建keyspace"><a href="#创建keyspace" class="headerlink" title="创建keyspace"></a>创建keyspace</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of   replicas’&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of  replicas’&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span> durable_writes = ‘<span class="built_in">Boolean</span> <span class="keyword">value</span>’;</span><br></pre></td></tr></table></figure>
<p>其中复制选项用于指定副本位置策略和所需副本的数量，另一个是是否持久化</p>
<h2 id="修改keyspace"><a href="#修改keyspace" class="headerlink" title="修改keyspace"></a>修改keyspace</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of  replicas’&#125;;</span><br></pre></td></tr></table></figure>
<p>对创建时的两个属性，复制和持久化作出修改</p>
<h2 id="删除keysopce"><a href="#删除keysopce" class="headerlink" title="删除keysopce"></a>删除keysopce</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> KEYSPACE “KeySpace <span class="keyword">name</span>”</span><br></pre></td></tr></table></figure>

<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (<span class="keyword">TABLE</span> | COLUMNFAMILY) &lt;tablename&gt;</span><br><span class="line">(<span class="string">'&lt;column-definition&gt;'</span> , <span class="string">'&lt;column-definition&gt;'</span>)</span><br><span class="line">(<span class="keyword">WITH</span> &lt;<span class="keyword">option</span>&gt; <span class="keyword">AND</span> &lt;<span class="keyword">option</span>&gt;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">   emp_id <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">   emp_name <span class="built_in">text</span>,</span><br><span class="line">   emp_city <span class="built_in">text</span>,</span><br><span class="line">   emp_sal varint,</span><br><span class="line">   emp_phone varint</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> (<span class="keyword">TABLE</span> | COLUMNFAMILY) &lt;tablename&gt; &lt;instruction&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> <span class="keyword">new</span> <span class="keyword">column</span> datatype</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> emp_email <span class="built_in">text</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> emp_email</span><br></pre></td></tr></table></figure>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename</span><br></pre></td></tr></table></figure>
<h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>(把数据都弄没）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> tabblename</span><br></pre></td></tr></table></figure>

<h2 id="创建、删除索引"><a href="#创建、删除索引" class="headerlink" title="创建、删除索引"></a>创建、删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> identifier <span class="keyword">on</span> tablename</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> <span class="keyword">name</span> <span class="keyword">on</span> emp1</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> identifier</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> batch </span><br><span class="line">&lt;<span class="keyword">insert</span>-stmt&gt;/ &lt;<span class="keyword">update</span>-stmt&gt;/ &lt;<span class="keyword">delete</span>-stmt&gt;</span><br><span class="line"><span class="keyword">apply</span> batch</span><br></pre></td></tr></table></figure>
<h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename (column1name,column2name...) <span class="keyword">values</span> (value1,value2...) <span class="keyword">using</span> &lt;<span class="keyword">option</span>&gt;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (emp_id, emp_city , emp_name , emp_phone, emp_sal ) <span class="keyword">values</span>(<span class="number">250</span>,<span class="string">'nanjing'</span>,<span class="string">'nidie'</span>,<span class="number">1234567</span>,<span class="number">88888</span>)  ;(cql中使用单引号）</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> columnname=value... <span class="keyword">where</span> condition</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> emp_city = <span class="string">'PPPPP'</span> <span class="keyword">WHERE</span> emp_id =<span class="number">250</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> tablename <span class="keyword">where</span> condition</span><br></pre></td></tr></table></figure>
<p>WHERE子句只能用于作为主键的一部分或在其上具有辅助索引的列。<br>不给where子句添加索引的情况下，会报错如下，加索引后就好了。</p>
<blockquote>
<p>InvalidRequest: Error from server: code=2200 [Invalid query] message=”Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING”</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> x <span class="keyword">from</span> identifier <span class="keyword">where</span> condition</span><br><span class="line">与更新一样，不加<span class="keyword">where</span>会报语法错误，有<span class="keyword">where</span>无条件变量会报<span class="keyword">no</span> viable alternative <span class="keyword">at</span> <span class="keyword">input</span> <span class="string">';'</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>CQL提供了许多内置类型包括集合，也可自定义，命令如下<br>    CREATE TYPE -创建用户定义的数据类型。</p>
<pre><code>ALTER TYPE -修改用户定义的数据类型。

DROP TYPE -删除用户定义的数据类型。

DESCRIBE TYPE -描述用户定义的数据类型。

DESCRIBE TYPES -描述用户定义的数据类型。</code></pre><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>适用于保持元素顺序且值被多次存储，格式同内建类型，只是插入时用[]括起来，中间,分割。更新时如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">data</span></span><br><span class="line">... <span class="keyword">SET</span> email = email +[<span class="string">'xyz@tutorialspoint.com'</span>]</span><br><span class="line">... <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'ramu'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>根据常识，无序且不重复</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data2 (<span class="keyword">name</span> <span class="built_in">text</span> PRIMARY <span class="keyword">KEY</span>, phone <span class="keyword">set</span>&lt;varint&gt;);</span><br><span class="line">花括号&#123;&#125;分割</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> data2(<span class="keyword">name</span>, phone)<span class="keyword">VALUES</span> (<span class="string">'rahman'</span>,    &#123;<span class="number">9848022338</span>,<span class="number">9848022339</span>&#125;);</span><br><span class="line">更新时同list</span><br><span class="line">tutorialspoint&gt; UPDATE data2</span><br><span class="line">   ... <span class="keyword">SET</span> phone = phone + &#123;<span class="number">9848022330</span>&#125;</span><br><span class="line">   ... <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'rahman'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>KV对</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data3 (<span class="keyword">name</span> <span class="built_in">text</span> PRIMARY <span class="keyword">KEY</span>, address</span><br><span class="line"><span class="keyword">map</span>&lt;<span class="built_in">timestamp</span>, <span class="built_in">text</span>&gt;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> data3 (<span class="keyword">name</span>, address)</span><br><span class="line">   <span class="keyword">VALUES</span> (<span class="string">'robin'</span>, &#123;<span class="string">'home'</span> : <span class="string">'hyderabad'</span> , <span class="string">'office'</span> : <span class="string">'Delhi'</span> &#125; );</span><br><span class="line">   <span class="keyword">UPDATE</span> data3</span><br><span class="line">   ... <span class="keyword">SET</span> address = address+&#123;<span class="string">'office'</span>:<span class="string">'mumbai'</span>&#125;</span><br><span class="line">   ... <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'robin'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> &lt;keyspace <span class="keyword">name</span>&gt;. &lt;<span class="keyword">data</span> typename&gt;</span><br><span class="line">( variable1, variable2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> tutorialspoint.card_details (</span><br><span class="line">   <span class="keyword">num</span> <span class="built_in">int</span>,</span><br><span class="line">   pin <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">   cvv <span class="built_in">int</span>,</span><br><span class="line">   phone <span class="keyword">set</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">   );</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TYPE</span> typename</span><br><span class="line"><span class="keyword">ADD</span> field_name field_type; </span><br><span class="line"></span><br><span class="line">DESCRIBE_TYPES命令验证所有用户定义的数据类型的列表</span><br></pre></td></tr></table></figure>














<h1 id="Seastar"><a href="#Seastar" class="headerlink" title="Seastar"></a>Seastar</h1><p>一个用于在现代多核机器上，编写高效复杂的服务器应用程序的C++库。它允许构建高度复杂的服务端应用程序，同时性能很好。它是事件驱动的，允许以相对直接的方式编写非阻塞的异步代码。<br>Scylladb第一个使用了Seastar，它是对Apache Cassandra的重写。 Cassandra是一个非常复杂的应用程序，然而，通过Seastar，我们能够让吞吐量提高10倍，同时显著的降低一致性的延迟。</p>
<blockquote>
<p>异步服务器应用程序的作者面临着今天仍面临的两大挑战：</p>
<p> 复杂性：编写简单的异步服务器非常简单。但是编写一个复杂的异步服务器是非常困难的。单个连接的处理，而不是一个简单易读的函数调用，现在涉及大量的小型回调函数和一个复杂的状态机，以记住每个事件发生时需要调用哪个函数。</p>
<p> 非阻塞：每个内核只有一个线程，对于服务器应用程序性能很重要，因为上下文切换很慢。但是，如果我们每个内核只有一个线程，则事件处理函数不能阻塞，否则内核将保持空闲状态。但是一些现有的编程语言和框架让服务器作者别无选择，只能使用阻塞函数，因此也不能使用多线程。例如，Cassandra被编写为一个异步服务器应用程序;但是因为磁盘I/O是用mmaped文件实现的，所以在访问时可以不受控制地阻塞整个线程，它们被迫在每个CPU上运行多个线程。</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/01/2019-05-31-Java%20%E4%B8%AD%20%E6%8C%89%E9%9C%80%E5%AF%BC%E6%AF%94%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%AF%BC%E5%85%A5%E6%85%A2%E5%A4%9A%E5%B0%91%EF%BC%9F/">Import * 真的比单项导入慢吗？</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-content"><p>在中间件考试的前一天，同学在群里问“写 Corba 代码的时候能使用 import * 吗？”，老师说这样会把无关的类写入字节码，最好不要这样。</p>
<p>因为当时已经学习过编译原理，顺便又在看《深入理解 Java Web 技术内幕》一书，于是对这个说法产生了很大的怀疑：Java 的编译器是如此不智能以至于 Bytecode 这种寸土寸金的地方都要因一句 <code>import *</code> 添加很多无关的字节吗？（肯定不会），但看的开源代码里基本从未见过 <code>import *</code>，都是一条条的导入 ，这又是为什么？<br>于是我用最常见的 Javac 编译器开始了实验…</p>
<h1 id="import-对-Javac生成的字节码的影响"><a href="#import-对-Javac生成的字节码的影响" class="headerlink" title="import * 对 Javac生成的字节码的影响"></a>import * 对 Javac生成的字节码的影响</h1><p>我们知道，在非静态导入的情况下，import 可以有 <code>import *</code> 和<code>import 具体类</code>两种形式，我们编写如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pre</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"abcd"</span>;</span><br><span class="line">        ConcurrentHashMap&lt;String,String &gt; chm=<span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            chm.put(String.valueOf(i),String.valueOf(i*i*i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str:chm.keySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(chm.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        pre(a,0,0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个版本唯一的不同是 第一行使用 <code>import java.util.concurrent.ConcurrentHashMap;</code><br>然后利用 <code>javac -verbose</code> 命令生成字节码，再利用 <code>javap</code> 反编译，查看 <code>.class</code> 文件的不同。<br>可以发现，除了类的名称以及因此引发的 MD5 等文件名不同以外，常量池并无不同。因此可以证明：<code>import *</code> 对 Javac 生成的字节码没有影响，或者说<strong><code>import *</code> 不会将多余的类写入字节码</strong>，那么，Java编译器对这种优化需要耗费多少时间呢？</p>
<h1 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h1><p>实践出真知，我们用最基本的脚本在我的小型服务器上进行测试，Shell 脚本如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for n in &#123;1..50&#125;;</span><br><span class="line">    do javac -verbose Pre.java &gt;&gt; log1.dat 2&gt;&amp;1; </span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">loop50次javac过程并输出时间（ms），1为按需导入，2为单项导入</span></span><br><span class="line">for n in &#123;1..50&#125;;</span><br><span class="line">    do javac -verbose Pre2.java &gt;&gt; log2.dat 2&gt;&amp;1;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重定向文件</span></span><br><span class="line">grep total log1.dat&gt;&gt;time1.dat 2&gt;&amp;1</span><br><span class="line">grep total log2.dat&gt;&gt;time2.dat 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">awk截取求和</span></span><br><span class="line">awk -F"[ ms]" '&#123;sum+= $2&#125; END &#123;print "import *= ", sum&#125;' time1.dat</span><br><span class="line">awk -F"[ ms]" '&#123;sum+= $2&#125; END &#123;print "import concurrenthashmap= ", sum&#125;' time2.dat</span><br></pre></td></tr></table></figure>
<p>之后 <code>nohup sh ./test.sh &amp;</code>测试，跑了多次，结果如下<br><img src="/img/D243310154EB89DCC999CB05B200D8E0.jpg" alt="结果"><br>可以看出，<code>import concurrenthashmap</code>确实是要比 <code>import *</code> 快的。那么，编译器究竟是在哪里进行了优化呢？</p>
<h1 id="底层探究"><a href="#底层探究" class="headerlink" title="底层探究"></a>底层探究</h1><p>结合以前编译原理的知识，我猜测是在生成抽象语法树 AST 的时候进行了优化，那么具体是怎么做到的呢？<br>值得注意的是，在上一步中 <code>javac -verbose Pre.java</code> ，（按需导入）时，静态加载只加载了 <code>Object</code> 和 <code>String</code> 两个类，然后才是<strong>[正在检查Pre]</strong>，随后才加载ConcurrentHashMap，信息如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]</span><br><span class="line">[正在检查Pre]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentHashMap.class)]]</span><br></pre></td></tr></table></figure>
<p>但在单项导入的文件中，ConcurrentHashMap是和 String、Object 一起加载的，代码如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentHashMap.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentLinkedDeque.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]</span><br><span class="line">[正在检查Pre2]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]</span><br></pre></td></tr></table></figure>
<p>从中可以看出，单项导入的时间要更早。<br>基于此我们去找 javac 的源码，通过阅读源码，笔者了解到：在 javac 的语法分析解析出 package 文法后（显然 Java 代码的第一行有可能并且基本都是 Package），会通过 <code>importDeclaration()</code>方法生产 <code>JCImport</code> 语法树，如果是 <code>import *</code>，那么树的叶子结点 <code>JCFieldAccess</code> 的 Token 名为 <code>asterisk</code> 并结束,这实际上是一个可替换的标识符。Javac 在<strong>语义分析</strong>时会按顺序在该类本身及其嵌套类、单类型导入、当前包找不到所需类后才去找按需导入并通过回溯那条 <code>import *</code>所指代的类的集合来寻找正确的类 替换AST，所以会额外增加编译时间。</p>
<p>等等，这是不是有些熟悉？先预编译，然后动态替换。是的，SQL 注入的预防就是用的类似的方法。</p>
<blockquote>
<p>在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库已参数化的形式进行查询，当运行时动态地把参数传给PreprareStatement时，即使参数里有敏感字符如 or ‘1=1’也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。</p>
</blockquote>
<h1 id="为啥不用？"><a href="#为啥不用？" class="headerlink" title="为啥不用？"></a>为啥不用？</h1><ol>
<li><ul>
<li>会提高读代码的难度————无法在一开始了解到这个 *.java 文件用到了什么类。</li>
</ul>
</li>
<li><p>可能造成名字空间的冲突，例如：<code>import a.*;</code> <code>import b.*;</code><br>如果包a和b中包含相同的类名会造成冲突。显示的写出每个import的类能够及早的发现问题。如果b包完全没有用到，则会造成不必要的冲突。</p>
</li>
<li><p>无用的import可能引入更多的无用的类库，在项目规模比较大的时候，对编译器可能会造成压力</p>
</li>
<li><p>无名包问题：如果在编译单元的顶部没有包声明，Java编译器首选会从无名包中搜索一个类型，然后才是按需类型声明。如果有命名冲突就会产生问题。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在 alibaba 或者 唯品会 的 Java 编码规范中并没有关于 import 的问题，但就我的测试和读到的一些JDK、Netty 的源码以及其他人写的 Java 代码来说：<br>非静态导入永远不用 <code>import *</code>，静态导入更不能用 <code>import *</code>（……）</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者借由一个简单的问题，通过读源码和实践的方式，探究了 <code>import *</code> 按需导入是否比 单项导入慢？慢多少？为什么慢？并由此联想和引出了预防 SQL 注入的基本原理，最后结合全文以及 Java 语言规范和 JDK 源码，给出了工程上关于 import 的最佳实践。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/2019-06-02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">二叉树中两节点的最近公共祖先问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span></div>
    </header>

    <div class="post-content"><p>除了一般的遍历做法，还给出了该问题批量查询最低常数时间复杂度的解法和批量查询M次，时间复杂度O(M+N)的做法。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p><img src="/img/2FCCB94DABAE923A3EF900C3150E88E1.jpg" alt="插图"><br>对于如上所示二叉树，节点8和5的最近公共祖先是2，节点9和6的最近公共祖先是1.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于二叉树问题，一个基本的思路就是遍历（另一个是直接设计递归），在遍历过程中加入一些操作，本题采用后序遍历。假设遍历左子树的返回结果为 left，右子树的返回结果为 right，当前节点为 cur。</p>
<ol>
<li>若 <code>cur=null/o1/o2</code>，返回cur</li>
<li>若 left 和 right 都为空，说明整个 cur 为 root 的子树都未发现过o1或者o2，返回 null。</li>
<li>若 left 和 right 都不为空，说明左右子树上都发现过 o1/o2，则 cur 就是其首次相遇地点，返回 cur</li>
<li>若 left 和right 一个为空一个不为空，假设不为空的那个记为 node，此时node 要么是 o1，o2中的一个，要么node 已经是o1、o2的最近公共祖先，直接返回node即可。</li>
</ol>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以上图中两目的节点为8和5来说明</p>
<ul>
<li><p>后序遍历结果为8，9，4，此时满足上述条件4，返回8</p>
</li>
<li><p>8，9，4，5，2，此时两个都不为空，满足条件3，首次在2相遇，返回2</p>
</li>
<li><p>8，9，4，5，2，6，7，3，此时一个为空一个不为空，满足条件4，返回2</p>
</li>
<li><p>最后遍历1，此时左子树返回2，右子树返回null，故最终返回2</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node left = lowestAncestor(head.left, o1, o2);</span><br><span class="line">		Node right = lowestAncestor(head.right, o1, o2);</span><br><span class="line">		<span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>如果查询次数很多，如何降低单次查询时间？</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>空间换时间即可，比如将任意两个节点作为o1,o2的答案缓存在哈希表中，查询时直接给出 key 得到 value。</p>
<ol>
<li><p>对二叉树中每一个子树都做步骤2</p>
</li>
<li><p>假设子树的头节点为h，h所有后代节点和h节点的最近公共祖先都是h；h左子树的每个节点和h右子树的每个节点的最近公共祖先都是h。</p>
</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, HashMap&lt;Node, Node&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			map = <span class="keyword">new</span> HashMap&lt;Node, HashMap&lt;Node, Node&gt;&gt;();</span><br><span class="line">			initMap(head);</span><br><span class="line">			setMap(head);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(head, <span class="keyword">new</span> HashMap&lt;Node, Node&gt;());</span><br><span class="line">			initMap(head.left);</span><br><span class="line">			initMap(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			headRecord(head.left, head);</span><br><span class="line">			headRecord(head.right, head);</span><br><span class="line">			subRecord(head);</span><br><span class="line">			setMap(head.left);</span><br><span class="line">			setMap(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">headRecord</span><span class="params">(Node n, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.get(n).put(h, h);</span><br><span class="line">			headRecord(n.left, h);</span><br><span class="line">			headRecord(n.right, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subRecord</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			preLeft(head.left, head.right, head);</span><br><span class="line">			subRecord(head.left);</span><br><span class="line">			subRecord(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preLeft</span><span class="params">(Node l, Node r, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			preRight(l, r, h);</span><br><span class="line">			preLeft(l.left, r, h);</span><br><span class="line">			preLeft(l.right, r, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRight</span><span class="params">(Node l, Node r, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.get(l).put(r, h);</span><br><span class="line">			preRight(l, r.left, h);</span><br><span class="line">			preRight(l, r.right, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">query</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1 == o2) &#123;</span><br><span class="line">				<span class="keyword">return</span> o1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(o1)) &#123;</span><br><span class="line">				<span class="keyword">return</span> map.get(o1).get(o2);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(o2)) &#123;</span><br><span class="line">				<span class="keyword">return</span> map.get(o2).get(o1);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>若二叉树节点数为N，枚举任意两个节点并记录其信息需要O(n^2)的时间复杂度，哈希表中数据查询的时间复杂度为常数级别。</p>
<h1 id="更好的时间复杂度"><a href="#更好的时间复杂度" class="headerlink" title="更好的时间复杂度"></a>更好的时间复杂度</h1><p>对节点数为N的二叉树，批量查询M次，要求时间复杂度达到O(M+N).<br>首先，存在一些可以直接返回的结果。<br>对于M次查询的每次o1，o2输入，以下三种情况直接返回：</p>
<ol>
<li><p>o1==o2，返回o1</p>
</li>
<li><p>o1,o2有且只有1个为null，返回非null的那一个</p>
</li>
<li><p>o1和o2都为null，返回null</p>
</li>
</ol>
<p>对于不能直接返回的结果，可以使用 tarjan 算法+并查集。</p>
<p>首先读入所有的询问关系(u,v)(即要求 LCA 的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问)。</p>
<p>接着对树进行后根次序遍历,每当对以一个树节点 u 的每一个子节点 v 为根的子树后根遍历完成后，将并查集中以该子节点 v 为根的集合(该集合包含了以该子女节点 v 为根的子树中的所有节点)并入并查集中以 u 为根的集合中(并入前该集合包含了 u 和以 v 之前所有子女节点为根的子树中的所有节点)当后根遍历完以u的所有子女节点 v 为根的子树并回溯至 u 本身后,将 u 的 visited  置 true(表示已访问)。</p>
<p>然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的 visited 标志位,如果该标志位为 false，什么也不做,进行最后一步,如果为 true,查找并查集中 i 所在集合的根节点 L,L 即为 u 和 i 的 LCA。最后一步,如果u有父节点 k，将以 u 为根的集合并入以 k 为根的集合中。接着继续后根遍历u的后继结点当整棵树后根遍历完成后，所有询问关系的 LCA 就全部求出了</p>
<p>不过一般我都直接后序遍历二叉树求解，这个难度过大，现写很容易挂，哈哈。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/68753603/answer/608919866" target="_blank" rel="noopener">知乎-如何理解 Tarjan 的 LCA 算法？</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/22/2019-06-03-Trie/">Trie树的构造与性质</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-22
        </span></div>
    </header>

    <div class="post-content"><p>本文介绍了 Trie（读同 Tree）树的定义、性质、实现以及应用。在刷 leetcode 时偶尔会用到，在一些经典问题的最优解如 “二叉树的最近公共祖先” 中也有涉及</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>字典树是一种树形结构，利用字符串的公共前缀来节约存储空间，一个保存了若干键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, and “inn”如图所示<br><img src="/img/9562B0F2A18AF2A1D23EB4B276FA7304.jpg" alt="插图"></p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>字典树基本性质如下</p>
<ol>
<li>根节点没有路径字符，其余每一个节点都被一个字符路径找到</li>
<li>从根节点到某一节点，将路径上经过的字符连起来为对应字符串</li>
<li>每个节点引出的所有字符路径上的字符都不一样</li>
</ol>
<h1 id="搜索与添加过程"><a href="#搜索与添加过程" class="headerlink" title="搜索与添加过程"></a>搜索与添加过程</h1><ol>
<li>从根节点开始搜索</li>
<li>取得要查找的单词的第一个字母，选择对应字符路径向下搜索</li>
<li>字符路径指向第二层节点上，根据第二个字母选择对应的字符继续搜索</li>
<li>一直向下搜索，如果单词搜索完后，最后一个节点是终止节点，说明找到。如果最后一个节点不是终止节点，或者还没搜索完单词就没有后续节点了，说明这个单词没添加过，不断生成新的节点并添加即可。</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="节点-TrieNode"><a href="#节点-TrieNode" class="headerlink" title="节点 TrieNode"></a>节点 TrieNode</h2><p>path 代表有多少单词公用这个节点，end表示有多少单词以该节点结尾，map的key 代表该节点的字符路径，value是字符路径指向的节点，在只有小写字母的情况下，map.length=26.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">		<span class="keyword">public</span> TrieNode[] map;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			path = <span class="number">0</span>;</span><br><span class="line">			end = <span class="number">0</span>;</span><br><span class="line">			map = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>设 str 长为n，从左到右遍历 str 中每个字符，并据此找下一个节点。如果找的过程中节点不存在，就新建节点，并令其 path = 1，如果存在，就令其 path++。通过最后一个字符找到最后一个节点时，令其path++，end++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			node.path++;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					node.map[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">				node.path++;</span><br><span class="line">			&#125;</span><br><span class="line">			node.end++;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>依次遍历 str 中每个字符，并依次从头节点开始根据每一个 字符找下一个节点，如果节点不存在，说明没有添加进 trie，返回 false，如果能通过 str[n-1]找到最后一个节点，记为e，若e.end!=0,说明有单词通过str[n-1]的字符路径，否则返回fasle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> node.end != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>先调用 search() 函数，看 str 在不在 Trie 中，若不在则直接返回。否则和上边一样，从左到右遍历 str 中每个字符并寻找下一个节点。扫的过程中，经过的每一个节点，其 path-1，若发现某 path 减完后已经为0，就从当前节点map中删除后续所有路径，然后返回。如果扫到最后一个即诶单，记为e，令e.path–,e.end–.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">				TrieNode node = root;</span><br><span class="line">				node.path--;</span><br><span class="line">				<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">					index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">					<span class="keyword">if</span> (node.map[index].path-- == <span class="number">1</span>) &#123;</span><br><span class="line">						node.map[index] = <span class="keyword">null</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					node = node.map[index];</span><br><span class="line">				&#125;</span><br><span class="line">				node.end--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回以-str-为前缀的单词数量"><a href="#返回以-str-为前缀的单词数量" class="headerlink" title="返回以 str 为前缀的单词数量"></a>返回以 str 为前缀的单词数量</h2><p>与查找操作类似，根据 pre 不断找到节点，返回最后的节点的 path 值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> node.path;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>是一种空间换时间的结构，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。从上述实现中可以看出，插入查询的时间复杂度都与待操作字符串长度线性相关。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol>
<li>查找</li>
<li>词频统计</li>
<li>字符串排序</li>
<li>前缀匹配</li>
<li>辅助结构如后缀树和AC自动机</li>
</ol>

        </div></article>
      <nav class="pagination"><a class="prev" href="/page/4/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/6/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:Dingbiao1998@icloud.com" target="_blank" rel="noopener" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Ubique0305" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Adam Ubik</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
