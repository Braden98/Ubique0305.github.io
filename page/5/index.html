<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Ubik的技术分享与学习记录"/><meta name="keywords" content="技术 Java Rust" /><link rel="alternate" href="/atom.xml" title="Ubik's blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=" />
<link rel="canonical" href="http://yoursite.com/page/5/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=" />

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7f52ad98103933a0875502b3b2a71682";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>Ubik's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Ubik's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Ubik's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/01/2019-07-05-Scylla&TiDB%20TiKV&glusterFS%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/">Scylla&TiDB TiKV&CQL 入门</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-content"><p>实习的第一件事就是读本组产品的 API 文档，然后学习系统用到的底层框架。这些东西之前从没看过。</p>
<h1 id="TiDB"><a href="#TiDB" class="headerlink" title="TiDB"></a>TiDB</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>OLTP (Online Transactional Processing) </p>
</li>
<li><p>OLAP (Online Analytical Processing) </p>
</li>
</ul>
<p>通过单机的 RocksDB，我们可以将数据快速地存储在磁盘上；通过 Raft，我们可以将数据复制到多台机器上，以防单机失效。数据的写入是通过 Raft 这一层的接口写入，而不是直接写 RocksDB。通过实现 Raft，我们拥有了一个分布式的 KV，现在再也不用担心某台机器挂掉了。</p>
<p>对于一个 KV 系统，将数据分散在多台机器上有两种比较典型的方案：一种是按照 Key 做 Hash，根据 Hash 值选择对应的存储节点；另一种是分 Range，某一段连续的 Key 都保存在一个存储节点上。TiKV 选择了第二种方式，将整个 Key-Value 空间分成很多段，每一段是一系列连续的 Key，我们将每一段叫做一个 Region，并且我们会尽量保持每个 Region 中保存的数据不超过一定的大小(这个大小可以配置，目前默认是 64mb)。每一个 Region 都可以用 StartKey 到 EndKey 这样一个左闭右开区间来描述。</p>
<p>TiKV 集群是 TiDB 数据库的分布式 KV 存储引擎，数据以 Region 为单位进行复制和管理，每个 Region 会有多个 Replica（副本），这些 Replica 会分布在不同的 TiKV 节点上，其中 Leader 负责读/写，Follower 负责同步 Leader 发来的 raft log</p>
<p><img src="/img/3DE33801F12030F0CB76AFE53384C6AA.jpg" alt="插图"></p>
<h1 id="glusterFS"><a href="#glusterFS" class="headerlink" title="glusterFS"></a>glusterFS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GlusterFS (Gluster File System) 是一个开源的分布式文件系统，是 Scale-Out 存储解决方案 Gluster 的核心，具有强大的横向扩展能力，通过扩展能够支持数PB存储容量和处理数千客户端。借助 TCP/IP 或 InfiniBand RDMA 网络将物理分布的存储资源聚集在一起，使用单一全局命名空间来管理数据。</p>
<h1 id="scylla"><a href="#scylla" class="headerlink" title="scylla"></a>scylla</h1><p>开源的分布式NoSQL数据存储。与Apache Cassandra兼容，同时实现更高的吞吐量和更低的延迟。<br><a href="http://www.nosqlnotes.com/technotes/scylla-highlights/" target="_blank" rel="noopener">号称十倍性能于Cassandra的ScyllaDB，究竟祭出了哪些技术”利器”？</a></p>
<h1 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h1><p>Apache Cassandra（社区内一般简称为C*）是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于储存收件箱等简单格式数据，具有高度可扩展性，可用于管理大量的结构化数据。它提供高可用性，没有单点故障,集 Google BigTable 的数据模型与 Amazon Dynamo 的完全分布式架构于一身。<br>Cassandra 使用了 Google 设计的 BigTable 的数据模型，与面向行 (row)的传统的关系型数据库或键值存储的key-value数据库不同，Cassandra 使用的是宽列存储模型(Wide Column Stores)，每行数据由row key唯一标识之后，可以有最多 20 亿个列，每个列有一个column key标识，每个column key下对应若干value。这种模型可以理解为是一个二维的key-value存储，即整个数据模型被定义成一个类似map&lt;key1, map&lt;key2,value&gt;&gt;的类型。<br><a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">wiki百科</a></p>
<h1 id="Cassandra-Query-Language-CQL-语法"><a href="#Cassandra-Query-Language-CQL-语法" class="headerlink" title="Cassandra Query Language (CQL) 语法"></a>Cassandra Query Language (CQL) 语法</h1><p>与SQL语法类似，但不支持join和子查询<br>结构类似HBase，row x key x value<br>常用命令</p>
<ul>
<li>describe tables</li>
<li>describe keyspaces</li>
<li>source 执行包含命令的文件</li>
</ul>
<p>键空间是一个定义节点上数据复制的命名空间，集群中每个节点对应一个键空间。<br>键、表、行关系通过expand on expand off 可以看的很明白<br>如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:tutorialspoint&gt; SELECT * from emp</span><br><span class="line">                  ... ;</span><br><span class="line"></span><br><span class="line">@ Row 1</span><br><span class="line"><span class="comment">-----------+------------</span></span><br><span class="line"> emp_id    | 4</span><br><span class="line"> emp_city  | Pune</span><br><span class="line"> emp_name  | rajeev</span><br><span class="line"> emp_phone | 9848022331</span><br><span class="line"> emp_sal   | 30000</span><br><span class="line"></span><br><span class="line">@ Row 2</span><br><span class="line"><span class="comment">-----------+------------</span></span><br><span class="line"> emp_id    | 3</span><br><span class="line"> emp_city  | null</span><br><span class="line"> emp_name  | null</span><br><span class="line"> emp_phone | null</span><br><span class="line"> emp_sal   | 50000</span><br><span class="line"></span><br><span class="line">(2 rows)</span><br><span class="line">cqlsh:tutorialspoint&gt; SELECT * from emp  ;</span><br><span class="line"></span><br><span class="line"> emp_id | emp_city | emp_name | emp_phone  | emp_sal</span><br><span class="line"><span class="comment">--------+----------+----------+------------+---------</span></span><br><span class="line">      4 |     Pune |   rajeev | 9848022331 |   30000</span><br><span class="line">      3 |     null |     null |       null |   50000</span><br></pre></td></tr></table></figure>
<h2 id="创建keyspace"><a href="#创建keyspace" class="headerlink" title="创建keyspace"></a>创建keyspace</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of   replicas’&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of  replicas’&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">AND</span> durable_writes = ‘<span class="built_in">Boolean</span> <span class="keyword">value</span>’;</span><br></pre></td></tr></table></figure>
<p>其中复制选项用于指定副本位置策略和所需副本的数量，另一个是是否持久化</p>
<h2 id="修改keyspace"><a href="#修改keyspace" class="headerlink" title="修改keyspace"></a>修改keyspace</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> KEYSPACE “KeySpace <span class="keyword">Name</span>”</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">replication</span> = &#123;<span class="string">'class'</span>: ‘Strategy <span class="keyword">name</span>’, <span class="string">'replication_factor'</span> : ‘No.Of  replicas’&#125;;</span><br></pre></td></tr></table></figure>
<p>对创建时的两个属性，复制和持久化作出修改</p>
<h2 id="删除keysopce"><a href="#删除keysopce" class="headerlink" title="删除keysopce"></a>删除keysopce</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> KEYSPACE “KeySpace <span class="keyword">name</span>”</span><br></pre></td></tr></table></figure>

<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> (<span class="keyword">TABLE</span> | COLUMNFAMILY) &lt;tablename&gt;</span><br><span class="line">(<span class="string">'&lt;column-definition&gt;'</span> , <span class="string">'&lt;column-definition&gt;'</span>)</span><br><span class="line">(<span class="keyword">WITH</span> &lt;<span class="keyword">option</span>&gt; <span class="keyword">AND</span> &lt;<span class="keyword">option</span>&gt;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">   emp_id <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">   emp_name <span class="built_in">text</span>,</span><br><span class="line">   emp_city <span class="built_in">text</span>,</span><br><span class="line">   emp_sal varint,</span><br><span class="line">   emp_phone varint</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> (<span class="keyword">TABLE</span> | COLUMNFAMILY) &lt;tablename&gt; &lt;instruction&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> <span class="keyword">new</span> <span class="keyword">column</span> datatype</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> emp_email <span class="built_in">text</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> emp_email</span><br></pre></td></tr></table></figure>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>语法与实例如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tablename</span><br></pre></td></tr></table></figure>
<h2 id="截断表"><a href="#截断表" class="headerlink" title="截断表"></a>截断表</h2><p>(把数据都弄没）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> tabblename</span><br></pre></td></tr></table></figure>

<h2 id="创建、删除索引"><a href="#创建、删除索引" class="headerlink" title="创建、删除索引"></a>创建、删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> identifier <span class="keyword">on</span> tablename</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> <span class="keyword">name</span> <span class="keyword">on</span> emp1</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> identifier</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>
<h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> batch </span><br><span class="line">&lt;<span class="keyword">insert</span>-stmt&gt;/ &lt;<span class="keyword">update</span>-stmt&gt;/ &lt;<span class="keyword">delete</span>-stmt&gt;</span><br><span class="line"><span class="keyword">apply</span> batch</span><br></pre></td></tr></table></figure>
<h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tablename (column1name,column2name...) <span class="keyword">values</span> (value1,value2...) <span class="keyword">using</span> &lt;<span class="keyword">option</span>&gt;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (emp_id, emp_city , emp_name , emp_phone, emp_sal ) <span class="keyword">values</span>(<span class="number">250</span>,<span class="string">'nanjing'</span>,<span class="string">'nidie'</span>,<span class="number">1234567</span>,<span class="number">88888</span>)  ;(cql中使用单引号）</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tablename <span class="keyword">set</span> columnname=value... <span class="keyword">where</span> condition</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> emp_city = <span class="string">'PPPPP'</span> <span class="keyword">WHERE</span> emp_id =<span class="number">250</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> tablename <span class="keyword">where</span> condition</span><br></pre></td></tr></table></figure>
<p>WHERE子句只能用于作为主键的一部分或在其上具有辅助索引的列。<br>不给where子句添加索引的情况下，会报错如下，加索引后就好了。</p>
<blockquote>
<p>InvalidRequest: Error from server: code=2200 [Invalid query] message=”Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING”</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> x <span class="keyword">from</span> identifier <span class="keyword">where</span> condition</span><br><span class="line">与更新一样，不加<span class="keyword">where</span>会报语法错误，有<span class="keyword">where</span>无条件变量会报<span class="keyword">no</span> viable alternative <span class="keyword">at</span> <span class="keyword">input</span> <span class="string">';'</span></span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>CQL提供了许多内置类型包括集合，也可自定义，命令如下<br>    CREATE TYPE -创建用户定义的数据类型。</p>
<pre><code>ALTER TYPE -修改用户定义的数据类型。

DROP TYPE -删除用户定义的数据类型。

DESCRIBE TYPE -描述用户定义的数据类型。

DESCRIBE TYPES -描述用户定义的数据类型。</code></pre><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>适用于保持元素顺序且值被多次存储，格式同内建类型，只是插入时用[]括起来，中间,分割。更新时如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">data</span></span><br><span class="line">... <span class="keyword">SET</span> email = email +[<span class="string">'xyz@tutorialspoint.com'</span>]</span><br><span class="line">... <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'ramu'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>根据常识，无序且不重复</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data2 (<span class="keyword">name</span> <span class="built_in">text</span> PRIMARY <span class="keyword">KEY</span>, phone <span class="keyword">set</span>&lt;varint&gt;);</span><br><span class="line">花括号&#123;&#125;分割</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> data2(<span class="keyword">name</span>, phone)<span class="keyword">VALUES</span> (<span class="string">'rahman'</span>,    &#123;<span class="number">9848022338</span>,<span class="number">9848022339</span>&#125;);</span><br><span class="line">更新时同list</span><br><span class="line">tutorialspoint&gt; UPDATE data2</span><br><span class="line">   ... <span class="keyword">SET</span> phone = phone + &#123;<span class="number">9848022330</span>&#125;</span><br><span class="line">   ... <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'rahman'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>KV对</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data3 (<span class="keyword">name</span> <span class="built_in">text</span> PRIMARY <span class="keyword">KEY</span>, address</span><br><span class="line"><span class="keyword">map</span>&lt;<span class="built_in">timestamp</span>, <span class="built_in">text</span>&gt;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> data3 (<span class="keyword">name</span>, address)</span><br><span class="line">   <span class="keyword">VALUES</span> (<span class="string">'robin'</span>, &#123;<span class="string">'home'</span> : <span class="string">'hyderabad'</span> , <span class="string">'office'</span> : <span class="string">'Delhi'</span> &#125; );</span><br><span class="line">   <span class="keyword">UPDATE</span> data3</span><br><span class="line">   ... <span class="keyword">SET</span> address = address+&#123;<span class="string">'office'</span>:<span class="string">'mumbai'</span>&#125;</span><br><span class="line">   ... <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'robin'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> &lt;keyspace <span class="keyword">name</span>&gt;. &lt;<span class="keyword">data</span> typename&gt;</span><br><span class="line">( variable1, variable2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> tutorialspoint.card_details (</span><br><span class="line">   <span class="keyword">num</span> <span class="built_in">int</span>,</span><br><span class="line">   pin <span class="built_in">int</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">text</span>,</span><br><span class="line">   cvv <span class="built_in">int</span>,</span><br><span class="line">   phone <span class="keyword">set</span>&lt;<span class="built_in">int</span>&gt;</span><br><span class="line">   );</span><br><span class="line">   </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TYPE</span> typename</span><br><span class="line"><span class="keyword">ADD</span> field_name field_type; </span><br><span class="line"></span><br><span class="line">DESCRIBE_TYPES命令验证所有用户定义的数据类型的列表</span><br></pre></td></tr></table></figure>














<h1 id="Seastar"><a href="#Seastar" class="headerlink" title="Seastar"></a>Seastar</h1><p>一个用于在现代多核机器上，编写高效复杂的服务器应用程序的C++库。它允许构建高度复杂的服务端应用程序，同时性能很好。它是事件驱动的，允许以相对直接的方式编写非阻塞的异步代码。<br>Scylladb第一个使用了Seastar，它是对Apache Cassandra的重写。 Cassandra是一个非常复杂的应用程序，然而，通过Seastar，我们能够让吞吐量提高10倍，同时显著的降低一致性的延迟。</p>
<blockquote>
<p>异步服务器应用程序的作者面临着今天仍面临的两大挑战：</p>
<p> 复杂性：编写简单的异步服务器非常简单。但是编写一个复杂的异步服务器是非常困难的。单个连接的处理，而不是一个简单易读的函数调用，现在涉及大量的小型回调函数和一个复杂的状态机，以记住每个事件发生时需要调用哪个函数。</p>
<p> 非阻塞：每个内核只有一个线程，对于服务器应用程序性能很重要，因为上下文切换很慢。但是，如果我们每个内核只有一个线程，则事件处理函数不能阻塞，否则内核将保持空闲状态。但是一些现有的编程语言和框架让服务器作者别无选择，只能使用阻塞函数，因此也不能使用多线程。例如，Cassandra被编写为一个异步服务器应用程序;但是因为磁盘I/O是用mmaped文件实现的，所以在访问时可以不受控制地阻塞整个线程，它们被迫在每个CPU上运行多个线程。</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/01/2019-05-31-Java%20%E4%B8%AD%20%E6%8C%89%E9%9C%80%E5%AF%BC%E6%AF%94%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%AF%BC%E5%85%A5%E6%85%A2%E5%A4%9A%E5%B0%91%EF%BC%9F/">Import * 真的比单项导入慢吗？</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-01
        </span></div>
    </header>

    <div class="post-content"><p>在中间件考试的前一天，同学在群里问“写 Corba 代码的时候能使用 import * 吗？”，老师说这样会把无关的类写入字节码，最好不要这样。</p>
<p>因为当时已经学习过编译原理，顺便又在看《深入理解 Java Web 技术内幕》一书，于是对这个说法产生了很大的怀疑：Java 的编译器是如此不智能以至于 Bytecode 这种寸土寸金的地方都要因一句 <code>import *</code> 添加很多无关的字节吗？（肯定不会），但看的开源代码里基本从未见过 <code>import *</code>，都是一条条的导入 ，这又是为什么？<br>于是我用最常见的 Javac 编译器开始了实验…</p>
<h1 id="import-对-Javac生成的字节码的影响"><a href="#import-对-Javac生成的字节码的影响" class="headerlink" title="import * 对 Javac生成的字节码的影响"></a>import * 对 Javac生成的字节码的影响</h1><p>我们知道，在非静态导入的情况下，import 可以有 <code>import *</code> 和<code>import 具体类</code>两种形式，我们编写如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pre</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"abcd"</span>;</span><br><span class="line">        ConcurrentHashMap&lt;String,String &gt; chm=<span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            chm.put(String.valueOf(i),String.valueOf(i*i*i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str:chm.keySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            System.out.println(chm.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"><span class="comment">//        pre(a,0,0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个版本唯一的不同是 第一行使用 <code>import java.util.concurrent.ConcurrentHashMap;</code><br>然后利用 <code>javac -verbose</code> 命令生成字节码，再利用 <code>javap</code> 反编译，查看 <code>.class</code> 文件的不同。<br>可以发现，除了类的名称以及因此引发的 MD5 等文件名不同以外，常量池并无不同。因此可以证明：<code>import *</code> 对 Javac 生成的字节码没有影响，或者说<strong><code>import *</code> 不会将多余的类写入字节码</strong>，那么，Java编译器对这种优化需要耗费多少时间呢？</p>
<h1 id="时间测试"><a href="#时间测试" class="headerlink" title="时间测试"></a>时间测试</h1><p>实践出真知，我们用最基本的脚本在我的小型服务器上进行测试，Shell 脚本如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for n in &#123;1..50&#125;;</span><br><span class="line">    do javac -verbose Pre.java &gt;&gt; log1.dat 2&gt;&amp;1; </span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash">loop50次javac过程并输出时间（ms），1为按需导入，2为单项导入</span></span><br><span class="line">for n in &#123;1..50&#125;;</span><br><span class="line">    do javac -verbose Pre2.java &gt;&gt; log2.dat 2&gt;&amp;1;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">重定向文件</span></span><br><span class="line">grep total log1.dat&gt;&gt;time1.dat 2&gt;&amp;1</span><br><span class="line">grep total log2.dat&gt;&gt;time2.dat 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">awk截取求和</span></span><br><span class="line">awk -F"[ ms]" '&#123;sum+= $2&#125; END &#123;print "import *= ", sum&#125;' time1.dat</span><br><span class="line">awk -F"[ ms]" '&#123;sum+= $2&#125; END &#123;print "import concurrenthashmap= ", sum&#125;' time2.dat</span><br></pre></td></tr></table></figure>
<p>之后 <code>nohup sh ./test.sh &amp;</code>测试，跑了多次，结果如下<br><img src="/img/D243310154EB89DCC999CB05B200D8E0.jpg" alt="结果"><br>可以看出，<code>import concurrenthashmap</code>确实是要比 <code>import *</code> 快的。那么，编译器究竟是在哪里进行了优化呢？</p>
<h1 id="底层探究"><a href="#底层探究" class="headerlink" title="底层探究"></a>底层探究</h1><p>结合以前编译原理的知识，我猜测是在生成抽象语法树 AST 的时候进行了优化，那么具体是怎么做到的呢？<br>值得注意的是，在上一步中 <code>javac -verbose Pre.java</code> ，（按需导入）时，静态加载只加载了 <code>Object</code> 和 <code>String</code> 两个类，然后才是<strong>[正在检查Pre]</strong>，随后才加载ConcurrentHashMap，信息如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]</span><br><span class="line">[正在检查Pre]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentHashMap.class)]]</span><br></pre></td></tr></table></figure>
<p>但在单项导入的文件中，ConcurrentHashMap是和 String、Object 一起加载的，代码如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentHashMap.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/util/concurrent/ConcurrentLinkedDeque.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class)]]</span><br><span class="line">[正在检查Pre2]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class)]]</span><br><span class="line">[正在加载ZipFileIndexFileObject[/Library/Java/JavaVirtualMachines/jdk1.8.0_161.jdk/Contents/Home/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class)]]</span><br></pre></td></tr></table></figure>
<p>从中可以看出，单项导入的时间要更早。<br>基于此我们去找 javac 的源码，通过阅读源码，笔者了解到：在 javac 的语法分析解析出 package 文法后（显然 Java 代码的第一行有可能并且基本都是 Package），会通过 <code>importDeclaration()</code>方法生产 <code>JCImport</code> 语法树，如果是 <code>import *</code>，那么树的叶子结点 <code>JCFieldAccess</code> 的 Token 名为 <code>asterisk</code> 并结束,这实际上是一个可替换的标识符。Javac 在<strong>语义分析</strong>时会按顺序在该类本身及其嵌套类、单类型导入、当前包找不到所需类后才去找按需导入并通过回溯那条 <code>import *</code>所指代的类的集合来寻找正确的类 替换AST，所以会额外增加编译时间。</p>
<p>等等，这是不是有些熟悉？先预编译，然后动态替换。是的，SQL 注入的预防就是用的类似的方法。</p>
<blockquote>
<p>在程序运行时第一次操作数据库之前，SQL语句已经被数据库分析，编译和优化，对应的执行计划也会缓存下来并允许数据库已参数化的形式进行查询，当运行时动态地把参数传给PreprareStatement时，即使参数里有敏感字符如 or ‘1=1’也数据库会作为一个参数一个字段的属性值来处理而不会作为一个SQL指令。</p>
</blockquote>
<h1 id="为啥不用？"><a href="#为啥不用？" class="headerlink" title="为啥不用？"></a>为啥不用？</h1><ol>
<li><ul>
<li>会提高读代码的难度————无法在一开始了解到这个 *.java 文件用到了什么类。</li>
</ul>
</li>
<li><p>可能造成名字空间的冲突，例如：<code>import a.*;</code> <code>import b.*;</code><br>如果包a和b中包含相同的类名会造成冲突。显示的写出每个import的类能够及早的发现问题。如果b包完全没有用到，则会造成不必要的冲突。</p>
</li>
<li><p>无用的import可能引入更多的无用的类库，在项目规模比较大的时候，对编译器可能会造成压力</p>
</li>
<li><p>无名包问题：如果在编译单元的顶部没有包声明，Java编译器首选会从无名包中搜索一个类型，然后才是按需类型声明。如果有命名冲突就会产生问题。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在 alibaba 或者 唯品会 的 Java 编码规范中并没有关于 import 的问题，但就我的测试和读到的一些JDK、Netty 的源码以及其他人写的 Java 代码来说：<br>非静态导入永远不用 <code>import *</code>，静态导入更不能用 <code>import *</code>（……）</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔者借由一个简单的问题，通过读源码和实践的方式，探究了 <code>import *</code> 按需导入是否比 单项导入慢？慢多少？为什么慢？并由此联想和引出了预防 SQL 注入的基本原理，最后结合全文以及 Java 语言规范和 JDK 源码，给出了工程上关于 import 的最佳实践。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/23/2019-06-02-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">二叉树中两节点的最近公共祖先问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-23
        </span></div>
    </header>

    <div class="post-content"><p>除了一般的遍历做法，还给出了该问题批量查询最低常数时间复杂度的解法和批量查询M次，时间复杂度O(M+N)的做法。</p>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p><img src="/img/2FCCB94DABAE923A3EF900C3150E88E1.jpg" alt="插图"><br>对于如上所示二叉树，节点8和5的最近公共祖先是2，节点9和6的最近公共祖先是1.</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于二叉树问题，一个基本的思路就是遍历（另一个是直接设计递归），在遍历过程中加入一些操作，本题采用后序遍历。假设遍历左子树的返回结果为 left，右子树的返回结果为 right，当前节点为 cur。</p>
<ol>
<li>若 <code>cur=null/o1/o2</code>，返回cur</li>
<li>若 left 和 right 都为空，说明整个 cur 为 root 的子树都未发现过o1或者o2，返回 null。</li>
<li>若 left 和 right 都不为空，说明左右子树上都发现过 o1/o2，则 cur 就是其首次相遇地点，返回 cur</li>
<li>若 left 和right 一个为空一个不为空，假设不为空的那个记为 node，此时node 要么是 o1，o2中的一个，要么node 已经是o1、o2的最近公共祖先，直接返回node即可。</li>
</ol>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以上图中两目的节点为8和5来说明</p>
<ul>
<li><p>后序遍历结果为8，9，4，此时满足上述条件4，返回8</p>
</li>
<li><p>8，9，4，5，2，此时两个都不为空，满足条件3，首次在2相遇，返回2</p>
</li>
<li><p>8，9，4，5，2，6，7，3，此时一个为空一个不为空，满足条件4，返回2</p>
</li>
<li><p>最后遍历1，此时左子树返回2，右子树返回null，故最终返回2</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">lowestAncestor</span><span class="params">(Node head, Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="keyword">null</span> || head == o1 || head == o2) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		Node left = lowestAncestor(head.left, o1, o2);</span><br><span class="line">		Node right = lowestAncestor(head.right, o1, o2);</span><br><span class="line">		<span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>如果查询次数很多，如何降低单次查询时间？</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>空间换时间即可，比如将任意两个节点作为o1,o2的答案缓存在哈希表中，查询时直接给出 key 得到 value。</p>
<ol>
<li><p>对二叉树中每一个子树都做步骤2</p>
</li>
<li><p>假设子树的头节点为h，h所有后代节点和h节点的最近公共祖先都是h；h左子树的每个节点和h右子树的每个节点的最近公共祖先都是h。</p>
</li>
</ol>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, HashMap&lt;Node, Node&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Record</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			map = <span class="keyword">new</span> HashMap&lt;Node, HashMap&lt;Node, Node&gt;&gt;();</span><br><span class="line">			initMap(head);</span><br><span class="line">			setMap(head);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.put(head, <span class="keyword">new</span> HashMap&lt;Node, Node&gt;());</span><br><span class="line">			initMap(head.left);</span><br><span class="line">			initMap(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			headRecord(head.left, head);</span><br><span class="line">			headRecord(head.right, head);</span><br><span class="line">			subRecord(head);</span><br><span class="line">			setMap(head.left);</span><br><span class="line">			setMap(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">headRecord</span><span class="params">(Node n, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.get(n).put(h, h);</span><br><span class="line">			headRecord(n.left, h);</span><br><span class="line">			headRecord(n.right, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subRecord</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			preLeft(head.left, head.right, head);</span><br><span class="line">			subRecord(head.left);</span><br><span class="line">			subRecord(head.right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preLeft</span><span class="params">(Node l, Node r, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			preRight(l, r, h);</span><br><span class="line">			preLeft(l.left, r, h);</span><br><span class="line">			preLeft(l.right, r, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preRight</span><span class="params">(Node l, Node r, Node h)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			map.get(l).put(r, h);</span><br><span class="line">			preRight(l, r.left, h);</span><br><span class="line">			preRight(l, r.right, h);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Node <span class="title">query</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1 == o2) &#123;</span><br><span class="line">				<span class="keyword">return</span> o1;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(o1)) &#123;</span><br><span class="line">				<span class="keyword">return</span> map.get(o1).get(o2);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(o2)) &#123;</span><br><span class="line">				<span class="keyword">return</span> map.get(o2).get(o1);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>若二叉树节点数为N，枚举任意两个节点并记录其信息需要O(n^2)的时间复杂度，哈希表中数据查询的时间复杂度为常数级别。</p>
<h1 id="更好的时间复杂度"><a href="#更好的时间复杂度" class="headerlink" title="更好的时间复杂度"></a>更好的时间复杂度</h1><p>对节点数为N的二叉树，批量查询M次，要求时间复杂度达到O(M+N).<br>首先，存在一些可以直接返回的结果。<br>对于M次查询的每次o1，o2输入，以下三种情况直接返回：</p>
<ol>
<li><p>o1==o2，返回o1</p>
</li>
<li><p>o1,o2有且只有1个为null，返回非null的那一个</p>
</li>
<li><p>o1和o2都为null，返回null</p>
</li>
</ol>
<p>对于不能直接返回的结果，可以使用 tarjan 算法+并查集。</p>
<p>首先读入所有的询问关系(u,v)(即要求 LCA 的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问)。</p>
<p>接着对树进行后根次序遍历,每当对以一个树节点 u 的每一个子节点 v 为根的子树后根遍历完成后，将并查集中以该子节点 v 为根的集合(该集合包含了以该子女节点 v 为根的子树中的所有节点)并入并查集中以 u 为根的集合中(并入前该集合包含了 u 和以 v 之前所有子女节点为根的子树中的所有节点)当后根遍历完以u的所有子女节点 v 为根的子树并回溯至 u 本身后,将 u 的 visited  置 true(表示已访问)。</p>
<p>然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的 visited 标志位,如果该标志位为 false，什么也不做,进行最后一步,如果为 true,查找并查集中 i 所在集合的根节点 L,L 即为 u 和 i 的 LCA。最后一步,如果u有父节点 k，将以 u 为根的集合并入以 k 为根的集合中。接着继续后根遍历u的后继结点当整棵树后根遍历完成后，所有询问关系的 LCA 就全部求出了</p>
<p>不过一般我都直接后序遍历二叉树求解，这个难度过大，现写很容易挂，哈哈。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/68753603/answer/608919866" target="_blank" rel="noopener">知乎-如何理解 Tarjan 的 LCA 算法？</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/22/2019-06-03-Trie/">Trie树的构造与性质</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-22
        </span></div>
    </header>

    <div class="post-content"><p>本文介绍了 Trie（读同 Tree）树的定义、性质、实现以及应用。在刷 leetcode 时偶尔会用到，在一些经典问题的最优解如 “二叉树的最近公共祖先” 中也有涉及</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>字典树是一种树形结构，利用字符串的公共前缀来节约存储空间，一个保存了若干键的trie结构，”A”, “to”, “tea”, “ted”, “ten”, “i”, “in”, and “inn”如图所示<br><img src="/img/9562B0F2A18AF2A1D23EB4B276FA7304.jpg" alt="插图"></p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>字典树基本性质如下</p>
<ol>
<li>根节点没有路径字符，其余每一个节点都被一个字符路径找到</li>
<li>从根节点到某一节点，将路径上经过的字符连起来为对应字符串</li>
<li>每个节点引出的所有字符路径上的字符都不一样</li>
</ol>
<h1 id="搜索与添加过程"><a href="#搜索与添加过程" class="headerlink" title="搜索与添加过程"></a>搜索与添加过程</h1><ol>
<li>从根节点开始搜索</li>
<li>取得要查找的单词的第一个字母，选择对应字符路径向下搜索</li>
<li>字符路径指向第二层节点上，根据第二个字母选择对应的字符继续搜索</li>
<li>一直向下搜索，如果单词搜索完后，最后一个节点是终止节点，说明找到。如果最后一个节点不是终止节点，或者还没搜索完单词就没有后续节点了，说明这个单词没添加过，不断生成新的节点并添加即可。</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="节点-TrieNode"><a href="#节点-TrieNode" class="headerlink" title="节点 TrieNode"></a>节点 TrieNode</h2><p>path 代表有多少单词公用这个节点，end表示有多少单词以该节点结尾，map的key 代表该节点的字符路径，value是字符路径指向的节点，在只有小写字母的情况下，map.length=26.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">		<span class="keyword">public</span> TrieNode[] map;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			path = <span class="number">0</span>;</span><br><span class="line">			end = <span class="number">0</span>;</span><br><span class="line">			map = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>设 str 长为n，从左到右遍历 str 中每个字符，并据此找下一个节点。如果找的过程中节点不存在，就新建节点，并令其 path = 1，如果存在，就令其 path++。通过最后一个字符找到最后一个节点时，令其path++，end++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			node.path++;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					node.map[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">				node.path++;</span><br><span class="line">			&#125;</span><br><span class="line">			node.end++;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>依次遍历 str 中每个字符，并依次从头节点开始根据每一个 字符找下一个节点，如果节点不存在，说明没有添加进 trie，返回 false，如果能通过 str[n-1]找到最后一个节点，记为e，若e.end!=0,说明有单词通过str[n-1]的字符路径，否则返回fasle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> node.end != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>先调用 search() 函数，看 str 在不在 Trie 中，若不在则直接返回。否则和上边一样，从左到右遍历 str 中每个字符并寻找下一个节点。扫的过程中，经过的每一个节点，其 path-1，若发现某 path 减完后已经为0，就从当前节点map中删除后续所有路径，然后返回。如果扫到最后一个即诶单，记为e，令e.path–,e.end–.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">				TrieNode node = root;</span><br><span class="line">				node.path--;</span><br><span class="line">				<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">					index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">					<span class="keyword">if</span> (node.map[index].path-- == <span class="number">1</span>) &#123;</span><br><span class="line">						node.map[index] = <span class="keyword">null</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					node = node.map[index];</span><br><span class="line">				&#125;</span><br><span class="line">				node.end--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回以-str-为前缀的单词数量"><a href="#返回以-str-为前缀的单词数量" class="headerlink" title="返回以 str 为前缀的单词数量"></a>返回以 str 为前缀的单词数量</h2><p>与查找操作类似，根据 pre 不断找到节点，返回最后的节点的 path 值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">char</span>[] chs = pre.toCharArray();</span><br><span class="line">			TrieNode node = root;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">				index = chs[i] - <span class="string">'a'</span>;</span><br><span class="line">				<span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.map[index];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> node.path;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>是一种空间换时间的结构，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。从上述实现中可以看出，插入查询的时间复杂度都与待操作字符串长度线性相关。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol>
<li>查找</li>
<li>词频统计</li>
<li>字符串排序</li>
<li>前缀匹配</li>
<li>辅助结构如后缀树和AC自动机</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/13/2019-07-17-%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E6%8E%A2%E7%B4%A2/">幂等性解决方案初探</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-13
        </span></div>
    </header>

    <div class="post-content"><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>讨论了幂等性的概念，在工业中遇到的问题、解决方案及在业务中的实际使用</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>幂等性原是数学上的概念，表述如下</p>
<p><code>f(f(x)) = f(x)</code></p>
<p>对应到软件领域，即为多次调用同一接口，结果一致。这里的结果包括服务器数据、状态，不包括返回值（如第一次写入成功，后续应为抛出异常或空操作，删除同理）。简单理解就是<strong>接口的可重复调用</strong>。<br>注意，数学上和工业上的<strong>幂等</strong>差别非常大，以下考虑都基于工业上的幂等。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>前端对同一表单数据的重复提交，后台应该只会产生一个结果</p>
</li>
<li><p>发起一笔付款请求，应该只扣用户账户一次钱，当遇到网络重发或系统bug重发，也应该只扣一次钱</p>
</li>
<li><p>发送消息，也应该只发一次，同样的短信如果多次发给用户，用户会崩溃</p>
</li>
<li><p>创建业务订单，一次业务请求只能创建一个，不能出现创建多个订单</p>
</li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h3 id="1-全局ID"><a href="#1-全局ID" class="headerlink" title="1. 全局ID"></a>1. 全局ID</h3><p>在执行操作前先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。如果不存在则把全局ID，存储到存储系统中，比如数据库、Redis等。如果存在则表示该方法已经执行。</p>
<h3 id="2-去重表"><a href="#2-去重表" class="headerlink" title="2. 去重表"></a>2. 去重表</h3><p>这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单ID可以作为唯一标识。这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。</p>
<p>这是利用数据库表单的特性来实现幂等。以订单请求支付场景为例：<br>将订单号orderId设为去重表的唯一索引，每次请求支付都根据订单号向去重表中插入一条数据，只有插入成功才继续执行支付操作，相当于在事务的开始阶段加锁。<br>考虑两种失败的情况：</p>
<p>Insert去重表失败，事务回滚，无任何影响；<br>Insert去重表成功，支付业务操作失败，事务回滚，删除之前插入去重表的记录，无任何影响；<br>以上两种失败的情况下，事务的幂等性是可以保持的，避免了单个订单同时多次进行支付的情况。<br>下图为该支付场景下的时序图：</p>
<p><img src="/img/7B339387CF3E7D841EAE7E1CC3FCE9BB.jpg" alt="插图"></p>
<h3 id="3-插入或更新"><a href="#3-插入或更新" class="headerlink" title="3. 插入或更新"></a>3. 插入或更新</h3><p>这种方法插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作</p>
<h3 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h3><p>在传统的基于数据库的架构中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，出于对性能以及一致性敏感度的要求，使得分布式锁成为了一种比较常见而高效的解决方案。</p>
<blockquote>
<p>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。</p>
</blockquote>
<p>与去重表思路相同，只是将对数据库的的访问转移到了对缓存（如redis）的访问，提高了效率。具体操作如下：<br>订单发起支付请求，支付系统会去redis缓存中查询是否存在该订单号orderId的key，如果不存在，则向redis增加key为订单号，然后开始实际支付操作；如果查询到存在该订单号的key，则不进行实际支付操作。无论支付操作成功或失败，在支付操作结果返回后，在缓存中删除该订单号key。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="如何防范表单-POST-重复提交？"><a href="#如何防范表单-POST-重复提交？" class="headerlink" title="如何防范表单 (POST) 重复提交？"></a>如何防范表单 (POST) 重复提交？</h2><p>HTTP POST 操作既不是安全的，也不是幂等的（至少在HTTP规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的POST请求，导致远端服务器重复创建出了资源。所以，对于电商应用来说，第一，对应的后端 WebService 一定要做到幂等性；第二，服务器端收到 POST 请求，在操作成功后必须302跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。</p>
<h2 id="分布式下异步"><a href="#分布式下异步" class="headerlink" title="分布式下异步"></a>分布式下异步</h2><p>分布式的很多业务考虑更多的是 BASE（即Basically Available、Soft state、和Eventually consistent），而不是 ACID（Atomicity、Consistency、Isolation和 Durability）。即为了满足高负载的用户访问，我们可以容忍短暂的数据不一致。那怎么做呢？</p>
<p>不做分布式事务，代价太大<br>不一定需要实时一致性，只需要保证最终的一致性即可<br>通过状态机和严格的有序操作，来最大限度地降低不一致性<br>最终一致性（Eventually Consistent）通过异步事件做到<br>如果消息具有操作幂等性，也就是一个消息被应用多次与应用一次产生的效果是一样的话，那么把不需要同步执行的事务交给异步消息推送和订阅者集群来处理即可。假如消息处理失败，那么就消息重播，由于幂等性，应用多次也能产生正确的结果。</p>
<p>实际情况下，消息很难具有幂等性，解决方法是使用另一个表记录已经被成功应用的消息，即消息队列和消息应用状态表一起来解决问题。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://segmentfault.com/a/1190000015884659" target="_blank" rel="noopener">幂等的实现方案</a></li>
<li><a href="https://www.caosh.me/be-tech/idempotence-using-unique-key/" target="_blank" rel="noopener">使用数据库唯一键实现事务幂等性</a></li>
</ol>

        </div></article>
      <nav class="pagination"><a class="prev" href="/page/4/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/6/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:Dingbiao1998@icloud.com" target="_blank" rel="noopener" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Ubique0305" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="copyright-year">&copy;2018 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Adam Ubik</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v="></script>
<script src="/node_modules/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"node_modules/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/node_modules/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
